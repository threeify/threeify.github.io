(function(exports){"use strict";const GL=WebGLRenderingContext;(function(ShaderType){ShaderType[ShaderType["Fragment"]=GL.FRAGMENT_SHADER]="Fragment";ShaderType[ShaderType["Vertex"]=GL.VERTEX_SHADER]="Vertex"})(exports.ShaderType||(exports.ShaderType={}));var __classPrivateFieldGet=undefined&&undefined.__classPrivateFieldGet||function(receiver,privateMap){if(!privateMap.has(receiver)){throw new TypeError("attempted to get private field on non-instance")}return privateMap.get(receiver)};var __classPrivateFieldSet=undefined&&undefined.__classPrivateFieldSet||function(receiver,privateMap,value){if(!privateMap.has(receiver)){throw new TypeError("attempted to set private field on non-instance")}privateMap.set(receiver,value);return value};var _validated;function insertLineNumbers(source){const inputLines=source.split("\n");const outputLines=["\n"];const maxLineCharacters=Math.floor(Math.log10(inputLines.length));for(let l=0;l<inputLines.length;l++){const lAsString=`000000${l+1}`.slice(-maxLineCharacters-1);outputLines.push(`${lAsString}: ${inputLines[l]}`)}return outputLines.join("\n")}function removeDeadCode(source){const defineRegexp=/^#define +([\w\d_]+)/;const undefRegexp=/^#undef +([\w\d_]+)/;const ifdefRegexp=/^#ifdef +([\w\d_]+)/;const ifndefRegexp=/^#ifndef +([\w\d_]+)/;const endifRegexp=/^#endif.* /;let defines=[];const liveCodeStack=[true];const outputLines=[];source.split("\n").forEach(line=>{const isLive=liveCodeStack[liveCodeStack.length-1];if(isLive){const defineMatch=line.match(defineRegexp);if(defineMatch!==null){defines.push(defineMatch[1])}const undefMatch=line.match(undefRegexp);if(undefMatch!==null){const indexOfDefine=defines.indexOf(undefMatch[1]);if(indexOfDefine>=0){defines=defines.splice(indexOfDefine,1)}}const ifdefMatch=line.match(ifdefRegexp);if(ifdefMatch!==null){liveCodeStack.push(defines.indexOf(ifdefMatch[1])>=0);return}const ifndefMatch=line.match(ifndefRegexp);if(ifndefMatch!==null){liveCodeStack.push(defines.indexOf(ifndefMatch[1])<0);return}}const endifMatch=line.match(endifRegexp);if(endifMatch!==null){liveCodeStack.pop();return}if(isLive){outputLines.push(line)}});return outputLines.join("\n").replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm,"").replace(/[\r\n]+/g,"\n")}class Shader{constructor(context,source,shaderType,glslVersion=300){this.context=context;this.source=source;this.shaderType=shaderType;this.glslVersion=glslVersion;this.disposed=false;_validated.set(this,false);const gl=this.context.gl;{const glShader=gl.createShader(shaderType);if(glShader===null){throw new Error("createShader failed")}this.glShader=glShader}const prefix=[];if(glslVersion===300){prefix.push("#version 300 es")}if(shaderType===exports.ShaderType.Fragment){const glxo=context.glxo;if(glxo.EXT_shader_texture_lod!==null){prefix.push("#extension GL_EXT_shader_texture_lod : enable")}prefix.push("#extension GL_OES_standard_derivatives : enable")}const combinedSource=prefix.join("\n")+"\n"+source;this.finalSource=removeDeadCode(combinedSource);gl.shaderSource(this.glShader,this.finalSource);gl.compileShader(this.glShader);this.id=this.context.registerResource(this)}get translatedSource(){const ds=this.context.glxo.WEBGL_debug_shaders;if(ds!==null){return ds.getTranslatedShaderSource(this.glShader)}return""}validate(){if(__classPrivateFieldGet(this,_validated)||this.disposed){return}const gl=this.context.gl;const compileStatus=gl.getShaderParameter(this.glShader,GL.COMPILE_STATUS);if(!compileStatus){const infoLog=gl.getShaderInfoLog(this.glShader);const errorMessage=`could not compile shader:\n${infoLog}`;console.error(errorMessage);console.error(insertLineNumbers(this.finalSource));this.disposed=true;throw new Error(errorMessage)}__classPrivateFieldSet(this,_validated,true)}dispose(){if(!this.disposed){this.context.gl.deleteShader(this.glShader);this.context.disposeResource(this);this.disposed=true}}}_validated=new WeakMap;exports.Shader=Shader;return exports})({});