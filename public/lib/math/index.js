(function(exports){"use strict";function normalizedByteToFloats(sourceArray,result=undefined){const scale=1/255;if(result===undefined){result=new Float32Array(sourceArray.length)}for(let i=0;i<sourceArray.length;i++){result[i]=sourceArray[i]*scale}return result}function floatsToNormalizedBytes(sourceArray,result=undefined){const scale=255;if(result===undefined){result=new Uint8Array(sourceArray.length)}for(let i=0;i<sourceArray.length;i++){result[i]=sourceArray[i]*scale}return result}function linearizeNumberInt32Array(array){const result=new Int32Array(array.length);for(let i=0;i<array.length;i++){result[i]=array[i]}return result}function linearizeNumberFloatArray(array){const result=new Float32Array(array.length);for(let i=0;i<array.length;i++){result[i]=array[i]}return result}function linearizeVector2FloatArray(array){const result=new Float32Array(array.length*2);for(let i=0;i<array.length;i++){array[i].toArray(result,i*2)}return result}function linearizeVector3FloatArray(array){const result=new Float32Array(array.length*3);for(let i=0;i<array.length;i++){array[i].toArray(result,i*3)}return result}function linearizeQuaternionFloatArray(array){const result=new Float32Array(array.length*4);for(let i=0;i<array.length;i++){array[i].toArray(result,i*4)}return result}function linearizeMatrix3FloatArray(array){const result=new Float32Array(array.length*9);for(let i=0;i<array.length;i++){array[i].toArray(result,i*9)}return result}function linearizeMatrix4FloatArray(array){const result=new Float32Array(array.length*16);for(let i=0;i<array.length;i++){array[i].toArray(result,i*16)}return result}const GL=WebGLRenderingContext;var ComponentType;(function(ComponentType){ComponentType[ComponentType["Byte"]=GL.BYTE]="Byte";ComponentType[ComponentType["UnsignedByte"]=GL.UNSIGNED_BYTE]="UnsignedByte";ComponentType[ComponentType["Short"]=GL.SHORT]="Short";ComponentType[ComponentType["UnsignedShort"]=GL.UNSIGNED_SHORT]="UnsignedShort";ComponentType[ComponentType["Int"]=GL.INT]="Int";ComponentType[ComponentType["UnsignedInt"]=GL.UNSIGNED_INT]="UnsignedInt";ComponentType[ComponentType["Float"]=GL.FLOAT]="Float"})(ComponentType||(ComponentType={}));function componentTypeSizeOf(componentType){switch(componentType){case ComponentType.Byte:case ComponentType.UnsignedByte:return 1;case ComponentType.Short:case ComponentType.UnsignedShort:return 2;case ComponentType.Float:case ComponentType.Int:case ComponentType.UnsignedInt:return 4}throw new Error(`unsupported component type: ${componentType}`)}const _lut=[];for(let i=0;i<256;i++){_lut[i]=(i<16?"0":"")+i.toString(16)}var BufferTarget;(function(BufferTarget){BufferTarget[BufferTarget["Array"]=GL.ARRAY_BUFFER]="Array";BufferTarget[BufferTarget["ElementArray"]=GL.ELEMENT_ARRAY_BUFFER]="ElementArray"})(BufferTarget||(BufferTarget={}));class Attribute{constructor(attributeData,componentsPerVertex,componentType,vertexStride,byteOffset,normalized){this.attributeData=attributeData;this.componentsPerVertex=componentsPerVertex;this.componentType=componentType;this.vertexStride=vertexStride;this.byteOffset=byteOffset;this.normalized=normalized;this.bytesPerComponent=componentTypeSizeOf(this.componentType);this.bytesPerVertex=this.bytesPerComponent*this.componentsPerVertex;if(this.vertexStride<0){this.vertexStride=this.bytesPerVertex}this.count=this.attributeData.arrayBuffer.byteLength/this.vertexStride}}const arrayBuffer=new ArrayBuffer(12*16);const floatArray=new Float32Array(arrayBuffer);const intArray=new Int32Array(arrayBuffer);function hashFloat2(v0,v1){floatArray[0]=v0;floatArray[1]=v1;const hash=intArray[0];return hash*397^intArray[1]}function hashFloat3(v0,v1,v2){floatArray[0]=v0;floatArray[1]=v1;floatArray[2]=v2;let hash=intArray[0]|0;hash=hash*397^(intArray[1]|0);return hash*397^(intArray[2]|0)}function hashFloat4(v0,v1,v2,v3){floatArray[0]=v0;floatArray[1]=v1;floatArray[2]=v2;floatArray[3]=v3;let hash=intArray[0]|0;hash=hash*397^(intArray[1]|0);hash=hash*397^(intArray[2]|0);return hash*397^(intArray[3]|0)}function hashFloatArray(elements){for(let i=0;i<elements.length;i++){floatArray[i]=elements[i]}let hash=intArray[0]|0;for(let i=1;i<16;i++){hash=hash*397^(intArray[i]|0)}return hash}function clamp(value,min,max){return Math.min(Math.max(value,min),max)}function degToRad(degrees){return degrees*(Math.PI/180)}function radToDeg(radian){return radian*(180/Math.PI)}function isPow2(value){return(value&value-1)===0&&value!==0}function ceilPow2(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2))}function floorPow2(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2))}class Vector2{constructor(x=0,y=0){this.x=x;this.y=y}get width(){return this.x}set width(width){this.x=width}get height(){return this.y}set height(height){this.y=height}getHashCode(){return hashFloat2(this.x,this.y)}set(x,y){this.x=x;this.y=y;return this}clone(){return(new Vector2).copy(this)}copy(v){return this.set(v.x,v.y)}add(v){this.x+=v.x;this.y+=v.y;return this}addScalar(s){this.x+=s;this.y+=s;return this}sub(v){this.x-=v.x;this.y-=v.y;return this}multiplyByScalar(s){this.x*=s;this.y*=s;return this}negate(){this.x*=-1;this.y*=-1;return this}normalize(){const length=this.length();return this.multiplyByScalar(length===0?1:0)}getComponent(index){if(index===0){return this.x}else if(index===1){return this.y}else{throw new Error(`index of our range: ${index}`)}}setComponent(index,value){if(index===0){this.x=value}else if(index===1){this.y=value}else{throw new Error(`index of our range: ${index}`)}return this}dot(v){return this.x*v.x+this.y*v.y}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x*this.x+this.y*this.y}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this}clamp(min,max){this.x=clamp(this.x,min.x,max.x);this.y=clamp(this.y,min.y,max.y);return this}equals(v){return v.x===this.x&&v.y===this.y}setFromArray(array,offset){this.x=array[offset+0];this.y=array[offset+1]}toArray(array,offset){array[offset+0]=this.x;array[offset+1]=this.y}}class Vector3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}get width(){return this.x}set width(width){this.x=width}get height(){return this.y}set height(height){this.y=height}get depth(){return this.z}set depth(depth){this.z=depth}get r(){return this.x}set r(r){this.x=r}get g(){return this.y}set g(g){this.y=g}get b(){return this.z}set b(b){this.z=b}getHashCode(){return hashFloat3(this.x,this.y,this.z)}set(x,y,z){this.x=x;this.y=y;this.z=z;return this}clone(){return(new Vector3).copy(this)}copy(v){return this.set(v.x,v.y,v.z)}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this}multiplyByScalar(s){this.x*=s;this.y*=s;this.z*=s;return this}negate(){this.x*=-1;this.y*=-1;this.z*=-1;return this}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this}normalize(){const length=this.length();return this.multiplyByScalar(length===0?1:1/length)}getComponent(index){if(index===0){return this.x}else if(index===1){return this.y}else if(index===2){return this.z}else{throw new Error(`index of our range: ${index}`)}}setComponent(index,value){if(index===0){this.x=value}else if(index===1){this.y=value}else if(index===2){this.z=value}else{throw new Error(`index of our range: ${index}`)}return this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z}cross(v){const ax=this.x,ay=this.y,az=this.z;const bx=v.x,by=v.y,bz=v.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}distanceToSquared(v){const dx=this.x-v.x;const dy=this.y-v.y;const dz=this.z-v.z;return dx*dx+dy*dy+dz*dz}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this}clamp(min,max){this.x=clamp(this.x,min.x,max.x);this.y=clamp(this.y,min.y,max.y);this.z=clamp(this.z,min.z,max.z);return this}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z}setFromArray(array,offset){this.x=array[offset+0];this.y=array[offset+1];this.z=array[offset+2]}toArray(array,offset){array[offset+0]=this.x;array[offset+1]=this.y;array[offset+2]=this.z}}class PrimitiveView{constructor(dataArray,floatPerPrimitive=-1,floatStride=-1,floatOffset=-1){this.floatStride=floatStride;this.floatOffset=floatOffset;if(dataArray instanceof Attribute){if(this.floatStride>=0){throw new Error("can not specify explicit byteStride when using Attribute argument")}if(this.floatOffset>=0){throw new Error("can not specify explicit byteOffset when using Attribute argument")}this.floatOffset=dataArray.byteOffset/4;this.floatStride=dataArray.vertexStride/4;this.floatArray=new Float32Array(dataArray.attributeData.arrayBuffer)}else if(dataArray instanceof Float32Array){this.floatArray=dataArray}else if(dataArray instanceof ArrayBuffer){this.floatArray=new Float32Array(dataArray)}else{throw new Error("unsupported value")}if(floatPerPrimitive<0){throw new Error("must specify bytesPerPrimitive or provide an Attribute argument")}if(this.floatStride<0){this.floatStride=floatPerPrimitive}if(this.floatOffset<0){this.floatOffset=0}this.count=this.floatArray.length/this.floatStride}set(index,v){v.toArray(this.floatArray,index*this.floatStride+this.floatOffset);return this}get(index,v){v.setFromArray(this.floatArray,index*this.floatStride+this.floatOffset);return v}}class Vector2View extends PrimitiveView{constructor(dataArray,floatStride=-1,floatOffset=-1){super(dataArray,2,floatStride,floatOffset);this.tempPrimitive=new Vector2}add(index,v){return this.set(index,this.get(index,this.tempPrimitive).add(v))}}class Vector3View extends PrimitiveView{constructor(dataArray,floatStride=-1,floatOffset=-1){super(dataArray,3,floatStride,floatOffset);this.tempPrimitive=new Vector3}add(index,v){return this.set(index,this.get(index,this.tempPrimitive).add(v))}}function makeVector2View(dataArray,floatStride=-1,floatOffset=-1){return new Vector2View(dataArray,floatStride,floatOffset)}function makeVector3View(dataArray,floatStride=-1,floatOffset=-1){return new Vector3View(dataArray,floatStride,floatOffset)}function makeQuaternionView(dataArray,floatStride=-1,floatOffset=-1){return new PrimitiveView(dataArray,4,floatStride,floatOffset)}function makeMatrix3View(dataArray,floatStride=-1,floatOffset=-1){return new PrimitiveView(dataArray,9,floatStride,floatOffset)}function makeMatrix4View(dataArray,floatStride=-1,floatOffset=-1){return new PrimitiveView(dataArray,16,floatStride,floatOffset)}class Box2{constructor(min=new Vector2(+Infinity,+Infinity),max=new Vector2(+Infinity,+Infinity)){this.min=min;this.max=max}get x(){return this.min.x}get y(){return this.min.y}get left(){return this.min.x}get top(){return this.min.y}get width(){return this.max.x-this.min.x}get height(){return this.max.y-this.min.y}get bottom(){return this.max.y}get right(){return this.max.x}getHashCode(){return hashFloat2(this.min.getHashCode(),this.max.getHashCode())}set(min,max){this.min.copy(min);this.max.copy(max);return this}clone(){return(new Box2).copy(this)}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this}getCenter(v){return v.set((this.min.x+this.max.x)*.5,(this.min.y+this.max.y)*.5)}makeEmpty(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}union(box){this.min.min(box.min);this.max.max(box.max);return this}translate(offset){this.min.add(offset);this.max.add(offset);return this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}}function makeBox2FromPoints(points,result=new Box2){result.makeEmpty();points.forEach(point=>{expandBox2ByPoint(result,point)});return result}function expandBox2ByPoint(b,point){b.min.min(point);b.max.max(point);return b}function box2ContainsVector2(b,point){return point.x<b.min.x||point.x>b.max.x||point.y<b.min.y||point.y>b.max.y?false:true}function box2ContainsBox2(b,otherBox){return b.min.x<=otherBox.min.x&&otherBox.max.x<=b.max.x&&b.min.y<=otherBox.min.y&&otherBox.max.y<=b.max.y}function clampVector2ToBox2(b,point){return(new Vector2).copy(point).clamp(b.min,b.max)}function distanceBox2ToVector2(b,point){const clampedPoint=(new Vector2).copy(point).clamp(b.min,b.max);return clampedPoint.sub(point).length()}class Box3{constructor(min=new Vector3(+Infinity,+Infinity,+Infinity),max=new Vector3(+Infinity,+Infinity,+Infinity)){this.min=min;this.max=max}getHashCode(){return hashFloat2(this.min.getHashCode(),this.max.getHashCode())}set(min,max){this.min.copy(min);this.max.copy(max);return this}clone(){return(new Box3).copy(this)}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this}getCenter(result=new Vector3){return result.set((this.min.x+this.max.x)*.5,(this.min.y+this.max.y)*.5,(this.min.z+this.max.z)*.5)}makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}expandByPoint(point){this.min.min(point);this.max.max(point);return this}expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this}intersect(box){this.min.max(box.min);this.max.min(box.max);return this}union(box){this.min.min(box.min);this.max.max(box.max);return this}translate(offset){this.min.add(offset);this.max.add(offset);return this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}}function transformPoint3(v,m,result=new Vector3){const x=v.x,y=v.y,z=v.z;const e=m.elements;const w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);result.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;result.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;result.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return result}function transformNormal3(v,m,result=new Vector3){const x=v.x,y=v.y,z=v.z;const e=m.elements;result.x=e[0]*x+e[4]*y+e[8]*z;result.y=e[1]*x+e[5]*y+e[9]*z;result.z=e[2]*x+e[6]*y+e[10]*z;return result.normalize()}function makeBox3FromArray(array,result=new Box3){let minX=+Infinity;let minY=+Infinity;let minZ=+Infinity;let maxX=-Infinity;let maxY=-Infinity;let maxZ=-Infinity;for(let i=0,l=array.length;i<l;i+=3){const x=array[i];const y=array[i+1];const z=array[i+2];if(x<minX){minX=x}if(y<minY){minY=y}if(z<minZ){minZ=z}if(x>maxX){maxX=x}if(y>maxY){maxY=y}if(z>maxZ){maxZ=z}}result.min.set(minX,minY,minZ);result.max.set(maxX,maxY,maxZ);return result}function makeBox3FromAttribute(attribute,result){let minX=+Infinity;let minY=+Infinity;let minZ=+Infinity;let maxX=-Infinity;let maxY=-Infinity;let maxZ=-Infinity;const v=new Vector3;const vectorView=new Vector3View(attribute);for(let i=0,l=attribute.count;i<l;i++){vectorView.get(i,v);if(v.x<minX){minX=v.x}if(v.y<minY){minY=v.y}if(v.z<minZ){minZ=v.z}if(v.x>maxX){maxX=v.x}if(v.y>maxY){maxY=v.y}if(v.z>maxZ){maxZ=v.z}}result.min.set(minX,minY,minZ);result.max.set(maxX,maxY,maxZ);return result}function makeBox3FromPoints(points,result=new Box3){result.makeEmpty();for(let i=0,il=points.length;i<il;i++){result.expandByPoint(points[i])}return result}function makeBox3FromCenterAndSize(center,size,result=new Box3){result.min.set(center.x-size.x*.5,center.y-size.y*.5,center.z-size.z*.5);result.max.set(center.x+size.x*.5,center.y+size.y*.5,center.z+size.z*.5);return result}function makeBox3FromSphereBounds(s,result=new Box3){if(s.isEmpty()){return result.makeEmpty()}result.set(s.center,s.center);return result.expandByScalar(s.radius)}function box3ContainsPoint(box,point){return point.x<box.min.x||point.x>box.max.x||point.y<box.min.y||point.y>box.max.y||point.z<box.min.z||point.z>box.max.z?false:true}function box3ContainsBox(box,queryBox){return box.min.x<=queryBox.min.x&&queryBox.max.x<=box.max.x&&box.min.y<=queryBox.min.y&&queryBox.max.y<=box.max.y&&box.min.z<=queryBox.min.z&&queryBox.max.z<=box.max.z}function box3ClampPoint(box,point,result=new Vector3){return result.copy(point).clamp(box.min,box.max)}function box3DistanceToPoint(box,point){return point.clone().clamp(box.min,box.max).sub(point).length()}function box3Box3Intersect(a,b,result){result.copy(a);result.min.max(b.min);result.max.min(b.max);return!result.isEmpty()}function box3Box3Union(a,b,result=new Box3){result.copy(a);result.expandByPoint(b.min);result.expandByPoint(b.max);return result}function transformBox3(b,m,result=new Box3){result.makeEmpty();if(b.isEmpty()){return result}const v=new Vector3;result.expandByPoint(transformPoint3(v.set(b.min.x,b.min.y,b.min.z),m,v));result.expandByPoint(transformPoint3(v.set(b.min.x,b.min.y,b.max.z),m,v));result.expandByPoint(transformPoint3(v.set(b.min.x,b.max.y,b.min.z),m,v));result.expandByPoint(transformPoint3(v.set(b.min.x,b.max.y,b.max.z),m,v));result.expandByPoint(transformPoint3(v.set(b.max.x,b.min.y,b.min.z),m,v));result.expandByPoint(transformPoint3(v.set(b.max.x,b.min.y,b.max.z),m,v));result.expandByPoint(transformPoint3(v.set(b.max.x,b.max.y,b.min.z),m,v));result.expandByPoint(transformPoint3(v.set(b.max.x,b.max.y,b.max.z),m,v));return result}function translateBox3(b,offset,result=new Box3){result.copy(b);result.min.add(offset);result.max.add(offset);return result}(function(EulerOrder){EulerOrder[EulerOrder["XYZ"]=0]="XYZ";EulerOrder[EulerOrder["YXZ"]=1]="YXZ";EulerOrder[EulerOrder["ZXY"]=2]="ZXY";EulerOrder[EulerOrder["ZYX"]=3]="ZYX";EulerOrder[EulerOrder["YZX"]=4]="YZX";EulerOrder[EulerOrder["XZY"]=5]="XZY";EulerOrder[EulerOrder["Default"]=0]="Default"})(exports.EulerOrder||(exports.EulerOrder={}));class Euler{constructor(x=0,y=0,z=0,order=exports.EulerOrder.Default){this.x=x;this.y=y;this.z=z;this.order=order}getHashCode(){return hashFloat4(this.x,this.y,this.z,this.order)}set(x,y,z,order=exports.EulerOrder.Default){this.x=x;this.y=y;this.z=z;this.order=order;return this}clone(){return(new Euler).copy(this)}copy(e){return this.set(e.x,e.y,e.z,e.order)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.order===this.order}setFromArray(array,offset){this.x=array[offset+0];this.y=array[offset+1];this.z=array[offset+2];this.order=array[offset+3]}toArray(array,offset){array[offset+0]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.order}}class Matrix4{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}getHashCode(){return hashFloatArray(this.elements)}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this}clone(){return(new Matrix4).copy(this)}copy(m){const me=m.elements;return this.set(me[0],me[4],me[8],me[12],me[1],me[5],me[9],me[13],me[2],me[6],me[10],me[14],me[3],me[7],me[11],me[15])}getComponent(index){return this.elements[index]}setComponent(index,value){this.elements[index]=value;return this}multiplyByScalar(s){const te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this}makeIdentity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}equals(m){for(let i=0;i<16;i++){if(m.elements[i]!==this.elements[i]){return false}}return true}setFromArray(array,offset){for(let i=0;i<this.elements.length;i++){this.elements[i]=array[offset+i]}}toArray(array,offset){for(let i=0;i<this.elements.length;i++){array[offset+i]=this.elements[i]}}}class Quaternion{constructor(x=0,y=0,z=0,w=1){this.x=x;this.y=y;this.z=z;this.w=w}getHashCode(){return hashFloat4(this.x,this.y,this.z,this.w)}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this}clone(){return(new Quaternion).copy(this)}copy(q){this.x=q.x;this.y=q.y;this.z=q.z;this.w=q.w;return this}add(q){this.x+=q.x;this.y+=q.y;this.z+=q.z;this.w+=q.w;return this}sub(q){this.x-=q.x;this.y-=q.y;this.z-=q.z;this.w-=q.w;return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error(`index of our range: ${index}`)}}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error(`index of our range: ${index}`)}return this}multiply(q){const qax=this.x,qay=this.y,qaz=this.z,qaw=this.w;const qbx=q.x,qby=q.y,qbz=q.z,qbw=q.w;this.x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this.y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this.z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this.w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;return this}angleTo(q){return 2*Math.acos(Math.abs(Math.min(Math.max(this.dot(q),-1),1)))}dot(q){return this.x*q.x+this.y*q.y+this.z*q.z+this.w*q.w}conjugate(){this.x*=-1;this.y*=-1;this.z*=-1;return this}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}normalize(){let l=this.length();if(l===0){this.x=0;this.y=0;this.z=0;this.w=1}else{l=1/l;this.x*=l;this.y*=l;this.z*=l;this.w*=l}return this}slerp(qb,t){if(t===0){return this}if(t===1){return this.copy(qb)}const x=this.x,y=this.y,z=this.z,w=this.w;let cosHalfTheta=w*qb.w+x*qb.x+y*qb.y+z*qb.z;if(cosHalfTheta<0){this.w=-qb.w;this.x=-qb.x;this.y=-qb.y;this.z=-qb.z;cosHalfTheta=-cosHalfTheta}else{this.copy(qb)}if(cosHalfTheta>=1){this.w=w;this.x=x;this.y=y;this.z=z;return this}const sqrSinHalfTheta=1-cosHalfTheta*cosHalfTheta;if(sqrSinHalfTheta<=Number.EPSILON){const s=1-t;this.w=s*w+t*this.w;this.x=s*x+t*this.x;this.y=s*y+t*this.y;this.z=s*z+t*this.z;this.normalize();return this}const sinHalfTheta=Math.sqrt(sqrSinHalfTheta);const halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);const ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this.w=w*ratioA+this.w*ratioB;this.x=x*ratioA+this.x*ratioB;this.y=y*ratioA+this.y*ratioB;this.z=z*ratioA+this.z*ratioB;return this}equals(q){return q.x===this.x&&q.y===this.y&&q.z===this.z&&q.w===this.w}setFromArray(floatArray,offset){this.x=floatArray[offset+0];this.y=floatArray[offset+1];this.z=floatArray[offset+2];this.w=floatArray[offset+3]}toArray(floatArray,offset){floatArray[offset+0]=this.x;floatArray[offset+1]=this.y;floatArray[offset+2]=this.z;floatArray[offset+3]=this.w}}function makeQuaternionFromEuler(e,result=new Quaternion){const x=e.x,y=e.y,z=e.z,order=e.order;const c1=Math.cos(x/2);const c2=Math.cos(y/2);const c3=Math.cos(z/2);const s1=Math.sin(x/2);const s2=Math.sin(y/2);const s3=Math.sin(z/2);switch(order){case exports.EulerOrder.XYZ:return result.set(s1*c2*c3+c1*s2*s3,c1*s2*c3-s1*c2*s3,c1*c2*s3+s1*s2*c3,c1*c2*c3-s1*s2*s3);case exports.EulerOrder.YXZ:return result.set(s1*c2*c3+c1*s2*s3,c1*s2*c3-s1*c2*s3,c1*c2*s3-s1*s2*c3,c1*c2*c3+s1*s2*s3);case exports.EulerOrder.ZXY:return result.set(s1*c2*c3-c1*s2*s3,c1*s2*c3+s1*c2*s3,c1*c2*s3+s1*s2*c3,c1*c2*c3-s1*s2*s3);case exports.EulerOrder.ZYX:return result.set(s1*c2*c3-c1*s2*s3,c1*s2*c3+s1*c2*s3,c1*c2*s3-s1*s2*c3,c1*c2*c3+s1*s2*s3);case exports.EulerOrder.YZX:return result.set(s1*c2*c3+c1*s2*s3,c1*s2*c3+s1*c2*s3,c1*c2*s3-s1*s2*c3,c1*c2*c3-s1*s2*s3);case exports.EulerOrder.XZY:return result.set(s1*c2*c3-c1*s2*s3,c1*s2*c3-s1*c2*s3,c1*c2*s3+s1*s2*c3,c1*c2*c3+s1*s2*s3);default:throw new Error("unsupported euler order")}}function makeQuaternionFromRotationMatrix4(m,result=new Quaternion){const te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){const s=.5/Math.sqrt(trace+1);return result.set((m32-m23)*s,(m13-m31)*s,(m21-m12)*s,.25/s)}if(m11>m22&&m11>m33){const s=2*Math.sqrt(1+m11-m22-m33);return result.set(.25*s,(m12+m21)/s,(m13+m31)/s,(m32-m23)/s)}if(m22>m33){const s=2*Math.sqrt(1+m22-m11-m33);return result.set((m12+m21)/s,.25*s,(m23+m32)/s,(m13-m31)/s)}const s=2*Math.sqrt(1+m33-m11-m22);return result.set((m13+m31)/s,(m23+m32)/s,.25*s,(m21-m12)/s)}function makeQuaternionFromAxisAngle(axis,angle,result=new Quaternion){const halfAngle=angle/2,s=Math.sin(halfAngle);return result.set(axis.x*s,axis.y*s,axis.z*s,Math.cos(halfAngle))}function makeQuaternionFromBaryCoordWeights(baryCoord,a,b,c,result=new Quaternion){const v=baryCoord;return result.set(a.x*v.x+b.x*v.y+c.x*v.z,a.y*v.x+b.y*v.y+c.y*v.z,a.z*v.x+b.z*v.y+c.z*v.z,a.w*v.x+b.w*v.y+c.w*v.z)}function makeMatrix4Concatenation(a,b,result=new Matrix4){const ae=a.elements;const be=b.elements;const te=result.elements;const a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];const a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];const a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];const a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];const b11=be[0],b12=be[4],b13=be[8],b14=be[12];const b21=be[1],b22=be[5],b23=be[9],b24=be[13];const b31=be[2],b32=be[6],b33=be[10],b34=be[14];const b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return result}function matrix4Determinant(m){const me=m.elements,n11=me[0],n21=me[1],n31=me[2],n41=me[3],n12=me[4],n22=me[5],n32=me[6],n42=me[7],n13=me[8],n23=me[9],n33=me[10],n43=me[11],n14=me[12],n24=me[13],n34=me[14],n44=me[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;return n11*t11+n21*t12+n31*t13+n41*t14}function makeMatrix4Transpose(m,result=new Matrix4){const re=result.copy(m).elements;let tmp;tmp=re[1];re[1]=re[4];re[4]=tmp;tmp=re[2];re[2]=re[8];re[8]=tmp;tmp=re[6];re[6]=re[9];re[9]=tmp;tmp=re[3];re[3]=re[12];re[12]=tmp;tmp=re[7];re[7]=re[13];re[13]=tmp;tmp=re[11];re[11]=re[14];re[14]=tmp;return result}function makeMatrix4Inverse(m,result=new Matrix4){const me=m.elements,n11=me[0],n21=me[1],n31=me[2],n41=me[3],n12=me[4],n22=me[5],n32=me[6],n42=me[7],n13=me[8],n23=me[9],n33=me[10],n43=me[11],n14=me[12],n24=me[13],n34=me[14],n44=me[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;const det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0){throw new Error("can not invert degenerate matrix")}const detInv=1/det;const re=result.elements;re[0]=t11*detInv;re[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;re[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;re[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;re[4]=t12*detInv;re[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;re[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;re[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;re[8]=t13*detInv;re[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;re[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;re[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;re[12]=t14*detInv;re[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;re[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;re[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return result}function makeMatrix4Translation(t,result=new Matrix4){return result.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1)}function makeMatrix4RotationFromAngleAxis(axis,angle,result=new Matrix4){const c=Math.cos(angle);const s=Math.sin(angle);const t=1-c;const x=axis.x,y=axis.y,z=axis.z;const tx=t*x,ty=t*y;return result.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1)}function makeMatrix4LookAt(eye,target,up,result=new Matrix4){const te=result.elements;const look=eye.clone().sub(target);const lookLength=look.length();if(lookLength===0){look.z=1}else{look.multiplyByScalar(1/lookLength)}const right=up.clone().cross(look);const rightLength=right.length();if(rightLength===0){if(Math.abs(up.z)===1){up.x+=1e-4}else{up.z+=1e-4}up.normalize();right.cross(up)}else{right.multiplyByScalar(1/rightLength)}const up2=look.clone().cross(right);te[0]=right.x;te[4]=up2.x;te[8]=look.x;te[1]=right.y;te[5]=up2.y;te[9]=look.y;te[2]=right.z;te[6]=up2.z;te[10]=look.z;return result}function makeMatrix4RotationFromEuler(euler,result=new Matrix4){const te=result.elements;const x=euler.x,y=euler.y,z=euler.z;const a=Math.cos(x),b=Math.sin(x);const c=Math.cos(y),d=Math.sin(y);const e=Math.cos(z),f=Math.sin(z);if(euler.order===exports.EulerOrder.XYZ){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c}else if(euler.order===exports.EulerOrder.YXZ){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c}else if(euler.order===exports.EulerOrder.ZXY){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c}else if(euler.order===exports.EulerOrder.ZYX){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c}else if(euler.order===exports.EulerOrder.YZX){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f}else if(euler.order===exports.EulerOrder.XZY){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac}te[3]=0;te[7]=0;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return result}function makeMatrix4RotationFromQuaternion(q,result=new Matrix4){return composeMatrix4(new Vector3,q,new Vector3(1,1,1),result)}function makeMatrix4Scale(s,result=new Matrix4){return result.set(s.x,0,0,0,0,s.y,0,0,0,0,s.z,0,0,0,0,1)}function makeMatrix4Shear(x,y,z,result=new Matrix4){return result.set(1,y,z,0,x,1,z,0,x,y,1,0,0,0,0,1)}function getMaxScaleOnAxis(m){const te=m.elements;const scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];const scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];const scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq))}function composeMatrix4(position,rotation,scale,result=new Matrix4){const x=rotation.x,y=rotation.y,z=rotation.z,w=rotation.w;const x2=x+x,y2=y+y,z2=z+z;const xx=x*x2,xy=x*y2,xz=x*z2;const yy=y*y2,yz=y*z2,zz=z*z2;const wx=w*x2,wy=w*y2,wz=w*z2;const sx=scale.x,sy=scale.y,sz=scale.z;return result.set((1-(yy+zz))*sx,(xy-wz)*sy,(xz+wy)*sz,position.x,(xy+wz)*sx,(1-(xx+zz))*sy,(yz-wx)*sz,position.y,(xz-wy)*sx,(yz+wx)*sy,(1-(xx+yy))*sz,position.z,0,0,0,1)}function decomposeMatrix4(m,position,rotation,scale){const te=m.elements;let sx=new Vector3(te[0],te[1],te[2]).length();const sy=new Vector3(te[4],te[5],te[6]).length();const sz=new Vector3(te[8],te[9],te[10]).length();if(matrix4Determinant(m)<0){sx=-sx}position.x=te[12];position.y=te[13];position.z=te[14];const m2=(new Matrix4).copy(m);const invSX=1/sx;const invSY=1/sy;const invSZ=1/sz;m2.elements[0]*=invSX;m2.elements[1]*=invSX;m2.elements[2]*=invSX;m2.elements[4]*=invSY;m2.elements[5]*=invSY;m2.elements[6]*=invSY;m2.elements[8]*=invSZ;m2.elements[9]*=invSZ;m2.elements[10]*=invSZ;makeQuaternionFromRotationMatrix4(m2,rotation);scale.x=sx;scale.y=sy;scale.z=sz;return m}function makeMatrix4Perspective(left,right,top,bottom,near,far,result=new Matrix4){const x=2*near/(right-left);const y=2*near/(top-bottom);const a=(right+left)/(right-left);const b=(top+bottom)/(top-bottom);const c=-(far+near)/(far-near);const d=-2*far*near/(far-near);return result.set(x,0,a,0,0,y,b,0,0,0,c,d,0,0,-1,0)}function makeMatrix4PerspectiveFov(verticalFov,near,far,zoom,aspectRatio,result=new Matrix4){const height=2*near*Math.tan(verticalFov*Math.PI/180)/zoom;const width=height*aspectRatio;const right=width*.5;const left=right-width;const top=height*.5;const bottom=top-height;return makeMatrix4Perspective(left,right,top,bottom,near,far,result)}function makeMatrix4Orthographic(left,right,top,bottom,near,far,result=new Matrix4){const w=1/(right-left);const h=1/(top-bottom);const p=1/(far-near);const x=(right+left)*w;const y=(top+bottom)*h;const z=(far+near)*p;return result.set(2*w,0,0,-x,0,2*h,0,-y,0,0,-2*p,-z,0,0,0,1)}function makeMatrix4OrthographicSimple(height,center,near,far,zoom,aspectRatio=1,result=new Matrix4){height/=zoom;const width=height*aspectRatio;const left=-width*.5+center.x;const right=left+width;const top=-height*.5+center.y;const bottom=top+height;return makeMatrix4Orthographic(left,right,top,bottom,near,far,result)}function makeEulerFromRotationMatrix4(m,order=exports.EulerOrder.Default,result=new Euler){const te=m.elements;const m11=te[0],m12=te[4],m13=te[8];const m21=te[1],m22=te[5],m23=te[9];const m31=te[2],m32=te[6],m33=te[10];let x=0,y=0,z=0;switch(order){case exports.EulerOrder.XYZ:y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<.9999999){x=Math.atan2(-m23,m33);z=Math.atan2(-m12,m11)}else{x=Math.atan2(m32,m22);z=0}break;case exports.EulerOrder.YXZ:x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<.9999999){y=Math.atan2(m13,m33);z=Math.atan2(m21,m22)}else{y=Math.atan2(-m31,m11);z=0}break;case exports.EulerOrder.ZXY:x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<.9999999){y=Math.atan2(-m31,m33);z=Math.atan2(-m12,m22)}else{y=0;z=Math.atan2(m21,m11)}break;case exports.EulerOrder.ZYX:y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<.9999999){x=Math.atan2(m32,m33);z=Math.atan2(m21,m11)}else{x=0;z=Math.atan2(-m12,m22)}break;case exports.EulerOrder.YZX:z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<.9999999){x=Math.atan2(-m23,m22);y=Math.atan2(-m31,m11)}else{x=0;y=Math.atan2(m13,m33)}break;case exports.EulerOrder.XZY:z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<.9999999){x=Math.atan2(m32,m22);y=Math.atan2(m13,m11)}else{x=Math.atan2(-m23,m33);y=0}break}return result.set(x,y,z,order)}function makeEulerFromQuaternion(q,order,result=new Euler){const m=makeMatrix4RotationFromQuaternion(q);return makeEulerFromRotationMatrix4(m,order,result)}class Line3{constructor(start=new Vector3,end=new Vector3){this.start=start;this.end=end}getHashCode(){return hashFloat2(this.start.getHashCode(),this.end.getHashCode())}set(start,end){this.start.copy(start);this.end.copy(end);return this}clone(){return(new Line3).copy(this)}copy(l){this.start.copy(l.start);this.end.copy(l.end);return this}equals(l){return l.start.equals(this.start)&&l.end.equals(this.end)}}class Matrix3{constructor(){this.elements=[1,0,0,0,1,0,0,0,1]}getHashCode(){return hashFloatArray(this.elements)}set(n11,n12,n13,n21,n22,n23,n31,n32,n33){const te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this}clone(){return(new Matrix3).copy(this)}copy(m){const te=this.elements;const me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this}getComponent(index){return this.elements[index]}setComponent(index,value){this.elements[index]=value;return this}multiplyByScalar(s){const te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this}makeIdentity(){this.set(1,0,0,0,1,0,0,0,1);return this}equals(m){for(let i=0;i<16;i++){if(m.elements[i]!==this.elements[i]){return false}}return true}setFromArray(floatArray,offset){for(let i=0;i<this.elements.length;i++){this.elements[i]=floatArray[offset+i]}}toArray(floatArray,offset){for(let i=0;i<this.elements.length;i++){floatArray[offset+i]=this.elements[i]}}}function makeMatrix3Concatenation(a,b,result=new Matrix3){const ae=a.elements;const be=b.elements;const te=result.elements;const a11=ae[0],a12=ae[3],a13=ae[6];const a21=ae[1],a22=ae[4],a23=ae[7];const a31=ae[2],a32=ae[5],a33=ae[8];const b11=be[0],b12=be[3],b13=be[6];const b21=be[1],b22=be[4],b23=be[7];const b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return result}function matrix3Determinant(m){const te=m.elements;const a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g}function makeMatrix3Transpose(m,result=new Matrix3){let tmp;const me=result.copy(m).elements;tmp=me[1];me[1]=me[3];me[3]=tmp;tmp=me[2];me[2]=me[6];me[6]=tmp;tmp=me[5];me[5]=me[7];me[7]=tmp;return result}function makeMatrix3Inverse(m,result=new Matrix3){const e=m.elements;const n11=e[0],n21=e[1],n31=e[2],n12=e[3],n22=e[4],n32=e[5],n13=e[6],n23=e[7],n33=e[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0){throw new Error("can not invert degenerate matrix")}const detInv=1/det;const re=result.elements;re[0]=t11*detInv;re[1]=(n31*n23-n33*n21)*detInv;re[2]=(n32*n21-n31*n22)*detInv;re[3]=t12*detInv;re[4]=(n33*n11-n31*n13)*detInv;re[5]=(n31*n12-n32*n11)*detInv;re[6]=t13*detInv;re[7]=(n21*n13-n23*n11)*detInv;re[8]=(n22*n11-n21*n12)*detInv;return result}function makeMatrix3Translation(t,result=new Matrix3){return result.set(1,0,t.x,0,1,t.y,0,0,1)}function makeMatrix3RotationFromAngle(angle,result=new Matrix3){const c=Math.cos(angle);const s=Math.sin(angle);return result.set(c,-s,0,s,c,0,0,0,1)}function makeMatrix3Scale(s,result=new Matrix3){return result.set(s.x,0,0,0,s.y,0,0,0,1)}class Plane{constructor(normal=new Vector3,constant=0){this.normal=normal;this.constant=constant}getHashCode(){return hashFloat4(this.normal.x,this.normal.y,this.normal.z,this.constant)}set(normal,constant){this.normal.copy(normal);this.constant=constant;return this}clone(){return(new Plane).copy(this)}copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this}normalize(){const inverseNormalLength=1/this.normal.length();this.normal.multiplyByScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this}negate(){this.constant*=-1;this.normal.negate();return this}equals(p){throw p.normal.equals(this.normal)&&p.constant===this.constant}}function crossFromCoplanarPoints(a,b,c,result=new Vector3){result.copy(c).sub(b);const v=a.clone().sub(b);return result.cross(v)}function makeVector3FromDelta(a,b,result=new Vector3){return result.copy(a).sub(b)}function pointToBaryCoords(a,b,c,point,result=new Vector3){const v0=makeVector3FromDelta(c,b);const v1=makeVector3FromDelta(b,a);const v2=makeVector3FromDelta(point,a);const dot00=v0.dot(v0);const dot01=v0.dot(v1);const dot02=v0.dot(v2);const dot11=v1.dot(v1);const dot12=v1.dot(v2);const denom=dot00*dot11-dot01*dot01;if(denom===0){return result.set(-2,-1,-1)}const invDenom=1/denom;const u=(dot11*dot02-dot01*dot12)*invDenom;const v=(dot00*dot12-dot01*dot02)*invDenom;return result.set(1-u-v,v,u)}function makeVector3FromBaryCoordWeights(baryCoord,a,b,c,result=new Vector3){const v=baryCoord;return result.set(a.x*v.x+b.x*v.y+c.x*v.z,a.y*v.x+b.y*v.y+c.y*v.z,a.z*v.x+b.z*v.y+c.z*v.z)}function makeColor3FromHex(hex,result=new Vector3){hex=Math.floor(hex);return result.set((hex>>16&255)/255,(hex>>8&255)/255,(hex&255)/255)}function hue2rgb(p,q,t){if(t<0){t+=1}if(t>1){t-=1}if(t<1/6){return p+(q-p)*6*t}if(t<1/2){return q}if(t<2/3){return p+(q-p)*6*(2/3-t)}return p}function makeColor3FromHSL(h,s,l,result=new Vector3){h=(h%1+1)%1;s=Math.min(Math.max(s,0),1);l=Math.min(Math.max(l,0),1);if(s===0){return result.set(1,1,1)}const p=l<=.5?l*(1+s):l+s-l*s;const q=2*l-p;return result.set(hue2rgb(q,p,h+1/3),hue2rgb(q,p,h),hue2rgb(q,p,h-1/3))}function makeHexFromColor3(c){return c.r*255<<16^c.g*255<<8^c.b*255<<0}function makeHexStringFromColor3(c){return("000000"+makeHexFromColor3(c).toString(16)).slice(-6)}function makeHSLFromColor3(c,target){const r=c.r,g=c.g,b=c.b;const max=Math.max(r,g,b);const min=Math.min(r,g,b);let hue=0,saturation=0;const lightness=(min+max)/2;if(min===max){hue=0;saturation=0}else{const delta=max-min;saturation=lightness<=.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break}hue/=6}target.h=hue;target.s=saturation;target.l=lightness;return target}function makePlaneFromCoplanarPoints(a,b,c,result=new Plane){crossFromCoplanarPoints(a,b,c,result.normal);result.normal.normalize();return makePlaneFromNormalAndCoplanarPoint(result.normal,a,result)}function makePlaneFromTriangle(t,result=new Plane){return makePlaneFromCoplanarPoints(t.a,t.b,t.c,result)}function makePlaneFromNormalAndCoplanarPoint(normal,point,result=new Plane){result.normal.copy(normal);result.constant=-point.dot(normal);return result}function planePointDistance(plane,point){return plane.normal.dot(point)+plane.constant}function planeSphereDistance(plane,sphere){return planePointDistance(plane,sphere.center)-sphere.radius}function projectPointOntoPlane(point,plane,result=new Vector3){const v=point.clone();return result.copy(plane.normal).multiplyByScalar(-planePointDistance(plane,v)).add(v)}class Ray{constructor(origin=new Vector3,direction=new Vector3(0,0,-1)){this.origin=origin;this.direction=direction}getHashCode(){return hashFloat2(this.origin.getHashCode(),this.direction.getHashCode())}set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this}clone(){return(new Ray).copy(this)}copy(r){this.origin.copy(r.origin);this.direction.copy(r.direction);return this}at(t,result){return result.copy(this.direction).multiplyByScalar(t).add(this.origin)}lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this}equals(r){return r.origin.equals(this.origin)&&r.direction.equals(this.direction)}}function rayDistanceToPlane(ray,plane){const denominator=plane.normal.dot(ray.direction);if(denominator===0){if(planePointDistance(plane,ray.origin)===0){return 0}return Number.NaN}const t=-(ray.origin.dot(plane.normal)+plane.constant)/denominator;return t>=0?t:Number.NaN}class Sphere{constructor(center=new Vector3,radius=-1){this.center=center;this.radius=radius}set(center,radius){this.center.copy(center);this.radius=radius;return this}clone(){return(new Sphere).copy(this)}copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this}isEmpty(){return this.radius<0}makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this}equals(s){return s.center.equals(this.center)&&s.radius===this.radius}}function makeBoundingSphereFromBox(box,result=new Sphere){box.getCenter(result.center);result.radius=box.min.distanceTo(box.max)*.5;return result}function makeSphereFromPoints(points,optionalCenter,result=new Sphere){if(optionalCenter!==undefined){result.center.copy(optionalCenter)}else{makeBox3FromPoints(points).getCenter(result.center)}let maxRadiusSq=0;for(let i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,result.center.distanceToSquared(points[i]))}result.radius=Math.sqrt(maxRadiusSq);return result}function sphereContainsPoint(sphere,point){return point.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius}function sphereDistanceToPoint(sphere,point){return point.distanceTo(sphere.center)-sphere.radius}function clampPointToSphere(sphere,point){const deltaLengthSq=sphere.center.distanceToSquared(point);if(deltaLengthSq>sphere.radius*sphere.radius){point.sub(sphere.center).normalize();point.multiplyByScalar(sphere.radius).add(sphere.center)}return point}function transformSphere(s,m,result=new Sphere){transformPoint3(s.center,m,result.center);result.radius=s.radius*getMaxScaleOnAxis(m);return result}function translateSphere(s,offset,result=new Sphere){result.copy(s);result.center.add(offset);return result}function scaleSphere(s,scale,result=new Sphere){result.copy(s);result.radius*=scale;return result}class Spherical{constructor(radius=1,phi=0,theta=0){this.radius=radius;this.phi=phi;this.theta=theta}getHashCode(){return hashFloat3(this.radius,this.phi,this.theta)}set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this}clone(){return(new Spherical).copy(this)}copy(s){this.radius=s.radius;this.phi=s.phi;this.theta=s.theta;return this}makeSafe(){const EPS=1e-6;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this}equals(s){return s.radius===this.radius&&s.phi===this.phi&&s.theta===this.theta}}function makeSphericalFromVector3(v,result=new Spherical){result.radius=v.length();if(result.radius===0){result.theta=0;result.phi=0}else{result.theta=Math.atan2(v.x,v.z);result.phi=Math.acos(Math.min(Math.max(v.y/result.radius,-1),1))}return result}class Triangle{constructor(a=new Vector3,b=new Vector3,c=new Vector3){this.a=a;this.b=b;this.c=c}getHashCode(){return hashFloat3(this.a.getHashCode(),this.b.getHashCode(),this.c.getHashCode())}set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this}clone(){return(new Triangle).copy(this)}copy(t){return this.set(t.a,t.b,t.c)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}function makeTriangleFromPointsAndIndices(points,i0,i1,i2,triangle=new Triangle){triangle.set(points[i0],points[i1],points[i2]);return triangle}function triangleArea(t){return crossFromCoplanarPoints(t.a,t.b,t.c).length()*.5}function triangleMidpoint(t,result=new Vector3){return result.copy(t.a).add(t.b).add(t.c).multiplyByScalar(1/3)}function triangleNormal(t,result=new Vector3){return crossFromCoplanarPoints(t.a,t.b,t.c,result).normalize()}function trianglePointToBaryCoords(t,point,result=new Vector3){return pointToBaryCoords(point,t.a,t.b,t.c,result)}function makeVector2FromBaryCoordWeights(baryCoord,a,b,c,result=new Vector2){const v=baryCoord;return result.set(a.x*v.x+b.x*v.y+c.x*v.z,a.y*v.x+b.y*v.y+c.y*v.z)}function makeVector2Fit(frame,target,result=new Vector2){result.copy(target);const fitScale=Math.min(frame.width/result.width,frame.height/result.height);result.multiplyByScalar(fitScale);return result}function makeVector2Fill(frame,target,result=new Vector2){result.copy(target);const fitScale=Math.max(frame.width/result.width,frame.height/result.height);result.multiplyByScalar(fitScale);return result}function transformPoint2(v,m,result=new Vector2){const x=v.x,y=v.y;const e=m.elements;const w=1/(e[2]*x+e[5]*y+e[8]);result.x=(e[0]*x+e[3]*y+e[6])*w;result.y=(e[1]*x+e[4]*y+e[7])*w;return result}function transformDirection2(v,m,result=new Vector2){const x=v.x,y=v.y;const e=m.elements;result.x=e[0]*x+e[3]*y;result.y=e[1]*x+e[4]*y;return result.normalize()}class Vector4{constructor(x=0,y=0,z=0,w=0){this.x=x;this.y=y;this.z=z;this.w=w}get r(){return this.x}set r(r){this.x=r}get g(){return this.y}set g(g){this.y=g}get b(){return this.z}set b(b){this.z=b}get a(){return this.w}set a(a){this.w=a}getHashCode(){return hashFloat4(this.x,this.y,this.z,this.w)}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this}clone(){return(new Vector4).copy(this)}copy(v){return this.set(v.x,v.y,v.z,v.w)}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this}multiplyByScalar(s){this.x*=s;this.y*=s;this.z*=s;this.w*=s;return this}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this}normalize(){const length=this.length();return this.multiplyByScalar(length===0?1:1/length)}getComponent(index){if(index===0){return this.x}else if(index===1){return this.y}else if(index===2){return this.z}else if(index===3){return this.w}else{throw new Error(`index of our range: ${index}`)}}setComponent(index,value){if(index===0){this.x=value}else if(index===1){this.y=value}else if(index===2){this.z=value}else if(index===3){this.w=value}else{throw new Error(`index of our range: ${index}`)}return this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w}setFromArray(array,offset){this.x=array[offset+0];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3]}toArray(array,offset){array[offset+0]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w}}function rgbeToLinear(source,result=new Vector4){const s=Math.pow(2,source.a*255-128);return result.set(source.r*s,source.g*s,source.b*s,1)}function linearToRgbd(source,maxRange,result=new Vector4){const maxRGB=Math.max(source.r,source.g,source.b);const realD=Math.max(maxRange/maxRGB,1);const normalizedD=clamp(Math.floor(realD)/255,0,1);const s=normalizedD*(255/maxRange);return result.set(source.r*s,source.g*s,source.b*s,normalizedD)}function linearToRgbd16(source,result=new Vector4){return linearToRgbd(source,16,result)}function rgbeToLinearArray(sourceArray,result=undefined){const sourceColor=new Vector4;const destColor=new Vector4;if(result===undefined){result=new Float32Array(sourceArray.length)}for(let i=0;i<sourceArray.length;i+=4){sourceColor.setFromArray(sourceArray,i);rgbeToLinear(sourceColor,destColor);destColor.toArray(result,i)}return result}function linearToRgbdArray(sourceArray,maxRange,result=undefined){const sourceColor=new Vector4;const destColor=new Vector4;if(result===undefined){result=new Float32Array(sourceArray.length)}for(let i=0;i<sourceArray.length;i+=4){sourceColor.setFromArray(sourceArray,i);linearToRgbd(sourceColor,maxRange,destColor);destColor.toArray(result,i)}return result}exports.Box2=Box2;exports.Box3=Box3;exports.Euler=Euler;exports.Line3=Line3;exports.Matrix3=Matrix3;exports.Matrix4=Matrix4;exports.Plane=Plane;exports.PrimitiveView=PrimitiveView;exports.Quaternion=Quaternion;exports.Ray=Ray;exports.Sphere=Sphere;exports.Spherical=Spherical;exports.Triangle=Triangle;exports.Vector2=Vector2;exports.Vector2View=Vector2View;exports.Vector3=Vector3;exports.Vector3View=Vector3View;exports.Vector4=Vector4;exports.box2ContainsBox2=box2ContainsBox2;exports.box2ContainsVector2=box2ContainsVector2;exports.box3Box3Intersect=box3Box3Intersect;exports.box3Box3Union=box3Box3Union;exports.box3ClampPoint=box3ClampPoint;exports.box3ContainsBox=box3ContainsBox;exports.box3ContainsPoint=box3ContainsPoint;exports.box3DistanceToPoint=box3DistanceToPoint;exports.ceilPow2=ceilPow2;exports.clamp=clamp;exports.clampPointToSphere=clampPointToSphere;exports.clampVector2ToBox2=clampVector2ToBox2;exports.composeMatrix4=composeMatrix4;exports.crossFromCoplanarPoints=crossFromCoplanarPoints;exports.decomposeMatrix4=decomposeMatrix4;exports.degToRad=degToRad;exports.distanceBox2ToVector2=distanceBox2ToVector2;exports.expandBox2ByPoint=expandBox2ByPoint;exports.floatsToNormalizedBytes=floatsToNormalizedBytes;exports.floorPow2=floorPow2;exports.getMaxScaleOnAxis=getMaxScaleOnAxis;exports.isPow2=isPow2;exports.linearToRgbd=linearToRgbd;exports.linearToRgbd16=linearToRgbd16;exports.linearToRgbdArray=linearToRgbdArray;exports.linearizeMatrix3FloatArray=linearizeMatrix3FloatArray;exports.linearizeMatrix4FloatArray=linearizeMatrix4FloatArray;exports.linearizeNumberFloatArray=linearizeNumberFloatArray;exports.linearizeNumberInt32Array=linearizeNumberInt32Array;exports.linearizeQuaternionFloatArray=linearizeQuaternionFloatArray;exports.linearizeVector2FloatArray=linearizeVector2FloatArray;exports.linearizeVector3FloatArray=linearizeVector3FloatArray;exports.makeBoundingSphereFromBox=makeBoundingSphereFromBox;exports.makeBox2FromPoints=makeBox2FromPoints;exports.makeBox3FromArray=makeBox3FromArray;exports.makeBox3FromAttribute=makeBox3FromAttribute;exports.makeBox3FromCenterAndSize=makeBox3FromCenterAndSize;exports.makeBox3FromPoints=makeBox3FromPoints;exports.makeBox3FromSphereBounds=makeBox3FromSphereBounds;exports.makeColor3FromHSL=makeColor3FromHSL;exports.makeColor3FromHex=makeColor3FromHex;exports.makeEulerFromQuaternion=makeEulerFromQuaternion;exports.makeEulerFromRotationMatrix4=makeEulerFromRotationMatrix4;exports.makeHSLFromColor3=makeHSLFromColor3;exports.makeHexFromColor3=makeHexFromColor3;exports.makeHexStringFromColor3=makeHexStringFromColor3;exports.makeMatrix3Concatenation=makeMatrix3Concatenation;exports.makeMatrix3Inverse=makeMatrix3Inverse;exports.makeMatrix3RotationFromAngle=makeMatrix3RotationFromAngle;exports.makeMatrix3Scale=makeMatrix3Scale;exports.makeMatrix3Translation=makeMatrix3Translation;exports.makeMatrix3Transpose=makeMatrix3Transpose;exports.makeMatrix3View=makeMatrix3View;exports.makeMatrix4Concatenation=makeMatrix4Concatenation;exports.makeMatrix4Inverse=makeMatrix4Inverse;exports.makeMatrix4LookAt=makeMatrix4LookAt;exports.makeMatrix4Orthographic=makeMatrix4Orthographic;exports.makeMatrix4OrthographicSimple=makeMatrix4OrthographicSimple;exports.makeMatrix4Perspective=makeMatrix4Perspective;exports.makeMatrix4PerspectiveFov=makeMatrix4PerspectiveFov;exports.makeMatrix4RotationFromAngleAxis=makeMatrix4RotationFromAngleAxis;exports.makeMatrix4RotationFromEuler=makeMatrix4RotationFromEuler;exports.makeMatrix4RotationFromQuaternion=makeMatrix4RotationFromQuaternion;exports.makeMatrix4Scale=makeMatrix4Scale;exports.makeMatrix4Shear=makeMatrix4Shear;exports.makeMatrix4Translation=makeMatrix4Translation;exports.makeMatrix4Transpose=makeMatrix4Transpose;exports.makeMatrix4View=makeMatrix4View;exports.makePlaneFromCoplanarPoints=makePlaneFromCoplanarPoints;exports.makePlaneFromNormalAndCoplanarPoint=makePlaneFromNormalAndCoplanarPoint;exports.makePlaneFromTriangle=makePlaneFromTriangle;exports.makeQuaternionFromAxisAngle=makeQuaternionFromAxisAngle;exports.makeQuaternionFromBaryCoordWeights=makeQuaternionFromBaryCoordWeights;exports.makeQuaternionFromEuler=makeQuaternionFromEuler;exports.makeQuaternionFromRotationMatrix4=makeQuaternionFromRotationMatrix4;exports.makeQuaternionView=makeQuaternionView;exports.makeSphereFromPoints=makeSphereFromPoints;exports.makeSphericalFromVector3=makeSphericalFromVector3;exports.makeTriangleFromPointsAndIndices=makeTriangleFromPointsAndIndices;exports.makeVector2Fill=makeVector2Fill;exports.makeVector2Fit=makeVector2Fit;exports.makeVector2FromBaryCoordWeights=makeVector2FromBaryCoordWeights;exports.makeVector2View=makeVector2View;exports.makeVector3FromBaryCoordWeights=makeVector3FromBaryCoordWeights;exports.makeVector3FromDelta=makeVector3FromDelta;exports.makeVector3View=makeVector3View;exports.matrix3Determinant=matrix3Determinant;exports.matrix4Determinant=matrix4Determinant;exports.normalizedByteToFloats=normalizedByteToFloats;exports.planePointDistance=planePointDistance;exports.planeSphereDistance=planeSphereDistance;exports.pointToBaryCoords=pointToBaryCoords;exports.projectPointOntoPlane=projectPointOntoPlane;exports.radToDeg=radToDeg;exports.rayDistanceToPlane=rayDistanceToPlane;exports.rgbeToLinear=rgbeToLinear;exports.rgbeToLinearArray=rgbeToLinearArray;exports.scaleSphere=scaleSphere;exports.sphereContainsPoint=sphereContainsPoint;exports.sphereDistanceToPoint=sphereDistanceToPoint;exports.transformBox3=transformBox3;exports.transformDirection2=transformDirection2;exports.transformNormal3=transformNormal3;exports.transformPoint2=transformPoint2;exports.transformPoint3=transformPoint3;exports.transformSphere=transformSphere;exports.translateBox3=translateBox3;exports.translateSphere=translateSphere;exports.triangleArea=triangleArea;exports.triangleMidpoint=triangleMidpoint;exports.triangleNormal=triangleNormal;exports.trianglePointToBaryCoords=trianglePointToBaryCoords;return exports})({});