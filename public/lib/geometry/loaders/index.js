(function(exports){"use strict";const GL=WebGLRenderingContext;var ComponentType;(function(ComponentType){ComponentType[ComponentType["Byte"]=GL.BYTE]="Byte";ComponentType[ComponentType["UnsignedByte"]=GL.UNSIGNED_BYTE]="UnsignedByte";ComponentType[ComponentType["Short"]=GL.SHORT]="Short";ComponentType[ComponentType["UnsignedShort"]=GL.UNSIGNED_SHORT]="UnsignedShort";ComponentType[ComponentType["Int"]=GL.INT]="Int";ComponentType[ComponentType["UnsignedInt"]=GL.UNSIGNED_INT]="UnsignedInt";ComponentType[ComponentType["Float"]=GL.FLOAT]="Float"})(ComponentType||(ComponentType={}));function componentTypeSizeOf(componentType){switch(componentType){case ComponentType.Byte:case ComponentType.UnsignedByte:return 1;case ComponentType.Short:case ComponentType.UnsignedShort:return 2;case ComponentType.Float:case ComponentType.Int:case ComponentType.UnsignedInt:return 4}throw new Error(`unsupported component type: ${componentType}`)}const _lut=[];for(let i=0;i<256;i++){_lut[i]=(i<16?"0":"")+i.toString(16)}function generateUUID(){const d0=Math.random()*4294967296|0;const d1=Math.random()*4294967296|0;const d2=Math.random()*4294967296|0;const d3=Math.random()*4294967296|0;const uuid=_lut[d0&255]+_lut[d0>>8&255]+_lut[d0>>16&255]+_lut[d0>>24&255]+"-"+_lut[d1&255]+_lut[d1>>8&255]+"-"+_lut[d1>>16&15|64]+_lut[d1>>24&255]+"-"+_lut[d2&63|128]+_lut[d2>>8&255]+"-"+_lut[d2>>16&255]+_lut[d2>>24&255]+_lut[d3&255]+_lut[d3>>8&255]+_lut[d3>>16&255]+_lut[d3>>24&255];return uuid.toUpperCase()}var BufferTarget;(function(BufferTarget){BufferTarget[BufferTarget["Array"]=GL.ARRAY_BUFFER]="Array";BufferTarget[BufferTarget["ElementArray"]=GL.ELEMENT_ARRAY_BUFFER]="ElementArray"})(BufferTarget||(BufferTarget={}));class AttributeData{constructor(arrayBuffer,target=BufferTarget.Array){this.arrayBuffer=arrayBuffer;this.target=target;this.disposed=false;this.uuid=generateUUID();this.version=0}dirty(){this.version++}dispose(){if(!this.disposed){this.disposed=true;this.dirty()}}}class Attribute{constructor(attributeData,componentsPerVertex,componentType,vertexStride,byteOffset,normalized){this.attributeData=attributeData;this.componentsPerVertex=componentsPerVertex;this.componentType=componentType;this.vertexStride=vertexStride;this.byteOffset=byteOffset;this.normalized=normalized;this.bytesPerComponent=componentTypeSizeOf(this.componentType);this.bytesPerVertex=this.bytesPerComponent*this.componentsPerVertex;if(this.vertexStride<0){this.vertexStride=this.bytesPerVertex}this.count=this.attributeData.arrayBuffer.byteLength/this.vertexStride}}function makeUint32Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Uint32Array?array:new Uint32Array(array)).buffer),componentsPerVertex,ComponentType.UnsignedInt,-1,0,normalized)}function makeFloat32Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Float32Array?array:new Float32Array(array)).buffer),componentsPerVertex,ComponentType.Float,-1,0,normalized)}var PrimitiveType;(function(PrimitiveType){PrimitiveType[PrimitiveType["Points"]=GL.POINTS]="Points";PrimitiveType[PrimitiveType["Lines"]=GL.LINES]="Lines";PrimitiveType[PrimitiveType["LineStrip"]=GL.LINE_STRIP]="LineStrip";PrimitiveType[PrimitiveType["Triangles"]=GL.TRIANGLES]="Triangles";PrimitiveType[PrimitiveType["TriangleFan"]=GL.TRIANGLE_FAN]="TriangleFan";PrimitiveType[PrimitiveType["TriangleStrip"]=GL.TRIANGLE_STRIP]="TriangleStrip"})(PrimitiveType||(PrimitiveType={}));class Geometry{constructor(){this.disposed=false;this.version=0;this.indices=undefined;this.attributes={};this.primitive=PrimitiveType.Triangles}dirty(){this.version++}dispose(){if(!this.disposed){for(const name in this.attributes){const attribute=this.attributes[name];if(attribute!==undefined){attribute.attributeData.dispose()}}this.disposed=true;this.dirty()}}}async function fetchOBJ(url){const response=await fetch(url);if(!response.ok){throw new Error("response error: "+response.status+":"+response.statusText)}return parseOBJ(await response.text())}const oRegexp=/^o +(.+)/;const gRegexp=/^g +(.+)/;const vRegexp=/^v +([\d.+-]+) +([\d.+-]+) +([\d.+-]+)/;const vnRegexp=/^vn +([\d.+-]+) +([\d.+-]+) +([\d.+-]+)/;const vtRegexp=/^vt +([\d.+-]+) +([\d.+-]+)/;const fRegexp=/^f( +(\d+)\/(\d*)\/(\d*))( +(\d+)\/(\d*)\/(\d*))( +(\d+)\/(\d*)\/(\d*))( +(\d+)\/(\d*)\/(\d*))?/;function parseOBJ(text){const geometries=[];let workingPositions=[];let workingNormals=[];let workingUvs=[];let positions=[];let normals=[];let uvs=[];let indices=[];function commitGroup(){if(indices.length===0){return}const geometry=new Geometry;geometry.indices=makeUint32Attribute(indices);geometry.attributes["position"]=makeFloat32Attribute(positions,3);geometry.attributes["normal"]=makeFloat32Attribute(normals,3);geometry.attributes["uv"]=makeFloat32Attribute(uvs,2);indices=[];positions=[];normals=[];uvs=[];geometries.push(geometry)}function commitObject(){commitGroup();workingPositions=[];workingNormals=[];workingUvs=[]}text.split("\n").forEach((function parseLine(line){const vMatch=line.match(vRegexp);if(vMatch!==null){workingPositions.push(parseFloat(vMatch[1]),parseFloat(vMatch[2]),parseFloat(vMatch[3]));return}const vnMatch=line.match(vnRegexp);if(vnMatch!==null){workingNormals.push(parseFloat(vnMatch[1]),parseFloat(vnMatch[2]),parseFloat(vnMatch[3]));return}const vtMatch=line.match(vtRegexp);if(vtMatch!==null){workingUvs.push(parseFloat(vtMatch[1]),parseFloat(vtMatch[2]));return}const fMatch=line.match(fRegexp);if(fMatch!==null){const startVertex=positions.length/3;let numVertices=3;if(fMatch[13]!==undefined){numVertices++}let baseOffset=2;for(let v=0;v<numVertices;v++){let pi=(parseInt(fMatch[baseOffset+0])-1)*3;if(pi<0){pi+=workingPositions.length/3}positions.push(workingPositions[pi],workingPositions[pi+1],workingPositions[pi+2]);const uvIndexToken=fMatch[baseOffset+1];if(uvIndexToken.length>0){let uvi=(parseInt(uvIndexToken)-1)*2;if(uvi<0){uvi+=workingUvs.length/2}uvs.push(workingUvs[uvi],workingUvs[uvi+1])}const normalIndexToken=fMatch[baseOffset+2];if(normalIndexToken.length>0){let ni=(parseInt(normalIndexToken)-1)*3;if(ni<0){ni+=workingNormals.length/3}normals.push(workingNormals[ni],workingNormals[ni+1],workingNormals[ni+2])}baseOffset+=4}for(let i=0;i<numVertices-2;i++){indices.push(startVertex);indices.push(startVertex+i+1);indices.push(startVertex+i+2)}}else if(oRegexp.test(line)){commitObject()}else if(gRegexp.test(line)){commitGroup()}}));commitObject();return geometries}exports.fetchOBJ=fetchOBJ;exports.parseOBJ=parseOBJ;return exports})({});