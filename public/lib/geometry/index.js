(function(exports,__){"use strict";const GL=WebGLRenderingContext;var ComponentType;(function(ComponentType){ComponentType[ComponentType["Byte"]=GL.BYTE]="Byte";ComponentType[ComponentType["UnsignedByte"]=GL.UNSIGNED_BYTE]="UnsignedByte";ComponentType[ComponentType["Short"]=GL.SHORT]="Short";ComponentType[ComponentType["UnsignedShort"]=GL.UNSIGNED_SHORT]="UnsignedShort";ComponentType[ComponentType["Int"]=GL.INT]="Int";ComponentType[ComponentType["UnsignedInt"]=GL.UNSIGNED_INT]="UnsignedInt";ComponentType[ComponentType["Float"]=GL.FLOAT]="Float"})(ComponentType||(ComponentType={}));function componentTypeSizeOf(componentType){switch(componentType){case ComponentType.Byte:case ComponentType.UnsignedByte:return 1;case ComponentType.Short:case ComponentType.UnsignedShort:return 2;case ComponentType.Float:case ComponentType.Int:case ComponentType.UnsignedInt:return 4}throw new Error(`unsupported component type: ${componentType}`)}const _lut=[];for(let i=0;i<256;i++){_lut[i]=(i<16?"0":"")+i.toString(16)}function generateUUID(){const d0=Math.random()*4294967296|0;const d1=Math.random()*4294967296|0;const d2=Math.random()*4294967296|0;const d3=Math.random()*4294967296|0;const uuid=_lut[d0&255]+_lut[d0>>8&255]+_lut[d0>>16&255]+_lut[d0>>24&255]+"-"+_lut[d1&255]+_lut[d1>>8&255]+"-"+_lut[d1>>16&15|64]+_lut[d1>>24&255]+"-"+_lut[d2&63|128]+_lut[d2>>8&255]+"-"+_lut[d2>>16&255]+_lut[d2>>24&255]+_lut[d3&255]+_lut[d3>>8&255]+_lut[d3>>16&255]+_lut[d3>>24&255];return uuid.toUpperCase()}var BufferTarget;(function(BufferTarget){BufferTarget[BufferTarget["Array"]=GL.ARRAY_BUFFER]="Array";BufferTarget[BufferTarget["ElementArray"]=GL.ELEMENT_ARRAY_BUFFER]="ElementArray"})(BufferTarget||(BufferTarget={}));class AttributeData{constructor(arrayBuffer,target=BufferTarget.Array){this.arrayBuffer=arrayBuffer;this.target=target;this.disposed=false;this.uuid=generateUUID();this.version=0}dirty(){this.version++}dispose(){if(!this.disposed){this.disposed=true;this.dirty()}}}class Attribute{constructor(attributeData,componentsPerVertex,componentType,vertexStride,byteOffset,normalized){this.attributeData=attributeData;this.componentsPerVertex=componentsPerVertex;this.componentType=componentType;this.vertexStride=vertexStride;this.byteOffset=byteOffset;this.normalized=normalized;this.bytesPerComponent=componentTypeSizeOf(this.componentType);this.bytesPerVertex=this.bytesPerComponent*this.componentsPerVertex;if(this.vertexStride<0){this.vertexStride=this.bytesPerVertex}this.count=this.attributeData.arrayBuffer.byteLength/this.vertexStride}}function makeUint8Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Uint8Array?array:new Uint8Array(array)).buffer),componentsPerVertex,ComponentType.UnsignedByte,-1,0,normalized)}function makeInt16Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Int16Array?array:new Int16Array(array)).buffer),componentsPerVertex,ComponentType.UnsignedShort,-1,0,normalized)}function makeUint32Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Uint32Array?array:new Uint32Array(array)).buffer),componentsPerVertex,ComponentType.UnsignedInt,-1,0,normalized)}function makeInt32Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Int32Array?array:new Int32Array(array)).buffer),componentsPerVertex,ComponentType.Int,-1,0,normalized)}function makeFloat32Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Float32Array?array:new Float32Array(array)).buffer),componentsPerVertex,ComponentType.Float,-1,0,normalized)}var PrimitiveType;(function(PrimitiveType){PrimitiveType[PrimitiveType["Points"]=GL.POINTS]="Points";PrimitiveType[PrimitiveType["Lines"]=GL.LINES]="Lines";PrimitiveType[PrimitiveType["LineStrip"]=GL.LINE_STRIP]="LineStrip";PrimitiveType[PrimitiveType["Triangles"]=GL.TRIANGLES]="Triangles";PrimitiveType[PrimitiveType["TriangleFan"]=GL.TRIANGLE_FAN]="TriangleFan";PrimitiveType[PrimitiveType["TriangleStrip"]=GL.TRIANGLE_STRIP]="TriangleStrip"})(PrimitiveType||(PrimitiveType={}));class Geometry{constructor(){this.disposed=false;this.version=0;this.indices=undefined;this.attributes={};this.primitive=PrimitiveType.Triangles}dirty(){this.version++}dispose(){if(!this.disposed){for(const name in this.attributes){const attribute=this.attributes[name];if(attribute!==undefined){attribute.attributeData.dispose()}}this.disposed=true;this.dirty()}}}const arrayBuffer=new ArrayBuffer(12*16);const floatArray=new Float32Array(arrayBuffer);const intArray=new Int32Array(arrayBuffer);function hashFloat2(v0,v1){floatArray[0]=v0;floatArray[1]=v1;const hash=intArray[0];return hash*397^intArray[1]}function hashFloat3(v0,v1,v2){floatArray[0]=v0;floatArray[1]=v1;floatArray[2]=v2;let hash=intArray[0]|0;hash=hash*397^(intArray[1]|0);return hash*397^(intArray[2]|0)}function clamp(value,min,max){return Math.min(Math.max(value,min),max)}class Vector2{constructor(x=0,y=0){this.x=x;this.y=y}get width(){return this.x}set width(width){this.x=width}get height(){return this.y}set height(height){this.y=height}getHashCode(){return hashFloat2(this.x,this.y)}set(x,y){this.x=x;this.y=y;return this}clone(){return(new Vector2).copy(this)}copy(v){return this.set(v.x,v.y)}add(v){this.x+=v.x;this.y+=v.y;return this}addScalar(s){this.x+=s;this.y+=s;return this}sub(v){this.x-=v.x;this.y-=v.y;return this}multiplyByScalar(s){this.x*=s;this.y*=s;return this}negate(){this.x*=-1;this.y*=-1;return this}normalize(){const length=this.length();return this.multiplyByScalar(length===0?1:0)}getComponent(index){if(index===0){return this.x}else if(index===1){return this.y}else{throw new Error(`index of our range: ${index}`)}}setComponent(index,value){if(index===0){this.x=value}else if(index===1){this.y=value}else{throw new Error(`index of our range: ${index}`)}return this}dot(v){return this.x*v.x+this.y*v.y}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x*this.x+this.y*this.y}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this}clamp(min,max){this.x=clamp(this.x,min.x,max.x);this.y=clamp(this.y,min.y,max.y);return this}equals(v){return v.x===this.x&&v.y===this.y}setFromArray(array,offset){this.x=array[offset+0];this.y=array[offset+1]}toArray(array,offset){array[offset+0]=this.x;array[offset+1]=this.y}}class Vector3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}get width(){return this.x}set width(width){this.x=width}get height(){return this.y}set height(height){this.y=height}get depth(){return this.z}set depth(depth){this.z=depth}get r(){return this.x}set r(r){this.x=r}get g(){return this.y}set g(g){this.y=g}get b(){return this.z}set b(b){this.z=b}getHashCode(){return hashFloat3(this.x,this.y,this.z)}set(x,y,z){this.x=x;this.y=y;this.z=z;return this}clone(){return(new Vector3).copy(this)}copy(v){return this.set(v.x,v.y,v.z)}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this}multiplyByScalar(s){this.x*=s;this.y*=s;this.z*=s;return this}negate(){this.x*=-1;this.y*=-1;this.z*=-1;return this}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this}normalize(){const length=this.length();return this.multiplyByScalar(length===0?1:1/length)}getComponent(index){if(index===0){return this.x}else if(index===1){return this.y}else if(index===2){return this.z}else{throw new Error(`index of our range: ${index}`)}}setComponent(index,value){if(index===0){this.x=value}else if(index===1){this.y=value}else if(index===2){this.z=value}else{throw new Error(`index of our range: ${index}`)}return this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z}cross(v){const ax=this.x,ay=this.y,az=this.z;const bx=v.x,by=v.y,bz=v.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}distanceToSquared(v){const dx=this.x-v.x;const dy=this.y-v.y;const dz=this.z-v.z;return dx*dx+dy*dy+dz*dz}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this}clamp(min,max){this.x=clamp(this.x,min.x,max.x);this.y=clamp(this.y,min.y,max.y);this.z=clamp(this.z,min.z,max.z);return this}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z}setFromArray(array,offset){this.x=array[offset+0];this.y=array[offset+1];this.z=array[offset+2]}toArray(array,offset){array[offset+0]=this.x;array[offset+1]=this.y;array[offset+2]=this.z}}class PrimitiveView{constructor(dataArray,floatPerPrimitive=-1,floatStride=-1,floatOffset=-1){this.floatStride=floatStride;this.floatOffset=floatOffset;if(dataArray instanceof Attribute){if(this.floatStride>=0){throw new Error("can not specify explicit byteStride when using Attribute argument")}if(this.floatOffset>=0){throw new Error("can not specify explicit byteOffset when using Attribute argument")}this.floatOffset=dataArray.byteOffset/4;this.floatStride=dataArray.vertexStride/4;this.floatArray=new Float32Array(dataArray.attributeData.arrayBuffer)}else if(dataArray instanceof Float32Array){this.floatArray=dataArray}else if(dataArray instanceof ArrayBuffer){this.floatArray=new Float32Array(dataArray)}else{throw new Error("unsupported value")}if(floatPerPrimitive<0){throw new Error("must specify bytesPerPrimitive or provide an Attribute argument")}if(this.floatStride<0){this.floatStride=floatPerPrimitive}if(this.floatOffset<0){this.floatOffset=0}this.count=this.floatArray.length/this.floatStride}set(index,v){v.toArray(this.floatArray,index*this.floatStride+this.floatOffset);return this}get(index,v){v.setFromArray(this.floatArray,index*this.floatStride+this.floatOffset);return v}}class Vector3View extends PrimitiveView{constructor(dataArray,floatStride=-1,floatOffset=-1){super(dataArray,3,floatStride,floatOffset);this.tempPrimitive=new Vector3}add(index,v){return this.set(index,this.get(index,this.tempPrimitive).add(v))}}function makeVector3View(dataArray,floatStride=-1,floatOffset=-1){return new Vector3View(dataArray,floatStride,floatOffset)}function copyBytesUsingStride(dest,source,bytesPerVertex,byteStridePerVertex,attributeOffset){const destBytes=new Int8Array(dest);const sourceBytes=new Int8Array(source);const vertexCount=source.byteLength/bytesPerVertex;for(let v=0;v<vertexCount;v++){const sourceOffset=v*bytesPerVertex;const destOffset=v*byteStridePerVertex+attributeOffset;for(let i=0;i<bytesPerVertex;i++){destBytes[destOffset+i]=sourceBytes[sourceOffset+i]}}}function convertToInterleavedGeometry(geometry){let byteStridePerVertex=0;let vertexCount=0;for(const name in geometry.attributes){const attribute=geometry.attributes[name];if(attribute!==undefined){byteStridePerVertex+=Math.max(attribute.bytesPerVertex,4);vertexCount=attribute.count}}const interleavedArray=new ArrayBuffer(byteStridePerVertex*vertexCount);const interleavedData=new AttributeData(interleavedArray);const interleavedGeometry=new Geometry;interleavedGeometry.indices=geometry.indices;let byteOffset=0;for(const name in geometry.attributes){const attribute=geometry.attributes[name];if(attribute!==undefined){copyBytesUsingStride(interleavedArray,attribute.attributeData.arrayBuffer,attribute.bytesPerVertex,byteStridePerVertex,byteOffset);interleavedGeometry.attributes[name]=new Attribute(interleavedData,attribute.componentsPerVertex,attribute.componentType,byteStridePerVertex,byteOffset,attribute.normalized);byteOffset+=Math.max(attribute.bytesPerVertex,4)}}return interleavedGeometry}function computeVertexNormals(geometry){const indicesAttribute=geometry.indices;const attributes=geometry.attributes;const positionAttribute=attributes["position"];if(positionAttribute===undefined){throw new Error("missing position attribute")}let normalAttribute=attributes["normal"];if(normalAttribute===undefined){normalAttribute=makeFloat32Attribute(new Float32Array(positionAttribute.count*3),3);geometry.attributes["normal"]=normalAttribute}const positions=makeVector3View(positionAttribute);const normals=makeVector3View(normalAttribute);for(let i=0,il=normals.count;i<il;i++){normals.set(i,new Vector3)}const pA=new Vector3;const pB=new Vector3;const pC=new Vector3;const cb=new Vector3;const ab=new Vector3;if(indicesAttribute!==undefined){const indices=new Uint32Array(indicesAttribute.attributeData.arrayBuffer);for(let i=0,il=indices.length;i<il;i+=3){const vA=indices[i+0];const vB=indices[i+1];const vC=indices[i+2];positions.get(vA,pA);positions.get(vB,pB);positions.get(vC,pC);cb.copy(pC).sub(pB);ab.copy(pA).sub(pB);cb.cross(ab);normals.add(vA,cb);normals.add(vB,cb);normals.add(vC,cb)}}else{for(let i=0,il=positions.count;i<il;i+=3){positions.get(i,pA);positions.get(i+1,pB);positions.get(i+2,pC);cb.copy(pC).sub(pB);ab.copy(pA).sub(pB);cb.cross(ab);normals.add(i,cb);normals.add(i+1,cb);normals.add(i+2,cb)}}const v=new Vector3;for(let i=0,il=normals.count;i<il;i+=3){normals.set(i,normals.get(i,v).normalize())}}function transformGeometry(geometry,m){const positionAttribute=geometry.attributes["position"];if(positionAttribute===undefined){throw new Error("missing position attribute")}const positions=makeVector3View(positionAttribute);const v=new Vector3;for(let i=0;i<positions.count;i++){positions.get(i,v);__.transformPoint3(v,m,v);positions.set(i,v)}const normalAttribute=geometry.attributes["normal"];if(normalAttribute!==undefined){const normals=makeVector3View(normalAttribute);for(let i=0;i<normals.count;i++){normals.get(i,v);__.transformNormal3(v,m,v);normals.set(i,v)}}}async function fetchOBJ(url){const response=await fetch(url);if(!response.ok){throw new Error("response error: "+response.status+":"+response.statusText)}return parseOBJ(await response.text())}const oRegexp=/^o +(.+)/;const gRegexp=/^g +(.+)/;const vRegexp=/^v +([\d.+-]+) +([\d.+-]+) +([\d.+-]+)/;const vnRegexp=/^vn +([\d.+-]+) +([\d.+-]+) +([\d.+-]+)/;const vtRegexp=/^vt +([\d.+-]+) +([\d.+-]+)/;const fRegexp=/^f( +(\d+)\/(\d*)\/(\d*))( +(\d+)\/(\d*)\/(\d*))( +(\d+)\/(\d*)\/(\d*))( +(\d+)\/(\d*)\/(\d*))?/;function parseOBJ(text){const geometries=[];let workingPositions=[];let workingNormals=[];let workingUvs=[];let positions=[];let normals=[];let uvs=[];let indices=[];function commitGroup(){if(indices.length===0){return}const geometry=new Geometry;geometry.indices=makeUint32Attribute(indices);geometry.attributes["position"]=makeFloat32Attribute(positions,3);geometry.attributes["normal"]=makeFloat32Attribute(normals,3);geometry.attributes["uv"]=makeFloat32Attribute(uvs,2);indices=[];positions=[];normals=[];uvs=[];geometries.push(geometry)}function commitObject(){commitGroup();workingPositions=[];workingNormals=[];workingUvs=[]}text.split("\n").forEach((function parseLine(line){const vMatch=line.match(vRegexp);if(vMatch!==null){workingPositions.push(parseFloat(vMatch[1]),parseFloat(vMatch[2]),parseFloat(vMatch[3]));return}const vnMatch=line.match(vnRegexp);if(vnMatch!==null){workingNormals.push(parseFloat(vnMatch[1]),parseFloat(vnMatch[2]),parseFloat(vnMatch[3]));return}const vtMatch=line.match(vtRegexp);if(vtMatch!==null){workingUvs.push(parseFloat(vtMatch[1]),parseFloat(vtMatch[2]));return}const fMatch=line.match(fRegexp);if(fMatch!==null){const startVertex=positions.length/3;let numVertices=3;if(fMatch[13]!==undefined){numVertices++}let baseOffset=2;for(let v=0;v<numVertices;v++){let pi=(parseInt(fMatch[baseOffset+0])-1)*3;if(pi<0){pi+=workingPositions.length/3}positions.push(workingPositions[pi],workingPositions[pi+1],workingPositions[pi+2]);const uvIndexToken=fMatch[baseOffset+1];if(uvIndexToken.length>0){let uvi=(parseInt(uvIndexToken)-1)*2;if(uvi<0){uvi+=workingUvs.length/2}uvs.push(workingUvs[uvi],workingUvs[uvi+1])}const normalIndexToken=fMatch[baseOffset+2];if(normalIndexToken.length>0){let ni=(parseInt(normalIndexToken)-1)*3;if(ni<0){ni+=workingNormals.length/3}normals.push(workingNormals[ni],workingNormals[ni+1],workingNormals[ni+2])}baseOffset+=4}for(let i=0;i<numVertices-2;i++){indices.push(startVertex);indices.push(startVertex+i+1);indices.push(startVertex+i+2)}}else if(oRegexp.test(line)){commitObject()}else if(gRegexp.test(line)){commitGroup()}}));commitObject();return geometries}function boxGeometry(width=1,height=1,depth=1,widthSegments=1,heightSegments=1,depthSegments=1){const indices=[];const vertices=[];const normals=[];const uvs=[];let numberOfVertices=0;function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY){const segmentWidth=width/gridX;const segmentHeight=height/gridY;const widthHalf=width/2;const heightHalf=height/2;const depthHalf=depth/2;const gridX1=gridX+1;const gridY1=gridY+1;const vector=new Vector3;for(let iy=0;iy<gridY1;iy++){const y=iy*segmentHeight-heightHalf;for(let ix=0;ix<gridX1;ix++){const x=ix*segmentWidth-widthHalf;vector.setComponent(u,x*udir);vector.setComponent(v,y*vdir);vector.setComponent(w,depthHalf);vertices.push(vector.x,vector.y,vector.z);vector.setComponent(u,0);vector.setComponent(v,0);vector.setComponent(w,depth>0?1:-1);normals.push(vector.x,vector.y,vector.z);uvs.push(ix/gridX);uvs.push(1-iy/gridY)}}for(let iy=0;iy<gridY;iy++){for(let ix=0;ix<gridX;ix++){const a=numberOfVertices+ix+gridX1*iy;const b=numberOfVertices+ix+gridX1*(iy+1);const c=numberOfVertices+(ix+1)+gridX1*(iy+1);const d=numberOfVertices+(ix+1)+gridX1*iy;indices.push(a,b,d);indices.push(b,c,d)}}numberOfVertices+=4}buildPlane(2,1,0,-1,-1,depth,height,width,depthSegments,heightSegments);buildPlane(2,1,0,1,-1,depth,height,-width,depthSegments,heightSegments);buildPlane(0,2,1,1,1,width,depth,height,widthSegments,depthSegments);buildPlane(0,2,1,1,-1,width,depth,-height,widthSegments,depthSegments);buildPlane(0,1,2,1,-1,width,height,depth,widthSegments,heightSegments);buildPlane(0,1,2,-1,-1,width,height,-depth,widthSegments,heightSegments);const geometry=new Geometry;geometry.indices=makeUint32Attribute(indices);geometry.attributes["position"]=makeFloat32Attribute(vertices,3);geometry.attributes["normal"]=makeFloat32Attribute(normals,3);geometry.attributes["uv"]=makeFloat32Attribute(uvs,2);return geometry}function cylinderGeometry(radius=.5,height=1,segments=8,thetaStart=0,thetaLength=Math.PI*2){const indicesTop=[];const verticesTop=[];const normalsTop=[];const uvsTop=[];const indicesBottom=[];const verticesBottom=[];const normalsBottom=[];const uvsBottom=[];const indicesSide=[];const verticesSide=[];const normalsSide=[];const uvsSide=[];const vertex=new Vector3;const uv=new Vector2;verticesTop.push(0,0,height*.5);normalsTop.push(0,0,1);uvsTop.push(.5,.5);verticesBottom.push(0,0,-height*.5);normalsBottom.push(0,0,-1);uvsBottom.push(.5,.5);for(let s=0,i=3;s<=segments;s++,i+=3){const segment=thetaStart+s/segments*thetaLength;vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);verticesTop.push(vertex.x,vertex.y,vertex.z+height*.5);verticesBottom.push(vertex.x,vertex.y,vertex.z-height*.5);verticesSide.push(vertex.x,vertex.y,vertex.z+height*.5);verticesSide.push(vertex.x,vertex.y,vertex.z-height*.5);normalsTop.push(0,0,1);normalsBottom.push(0,0,-1);normalsSide.push(Math.cos(segment),Math.sin(segment),0);normalsSide.push(Math.cos(segment),Math.sin(segment),0);uv.x=(verticesTop[i]/radius+1)/2;uv.y=(verticesTop[i+1]/radius+1)/2;uvsTop.push(uv.x,uv.y);uvsBottom.push(1-uv.x,1-uv.y);uvsSide.push(s/segments,0);uvsSide.push(s/segments,1)}const bo=verticesTop.length/3;const so=verticesTop.length/3*2;for(let i=1;i<=segments;i++){indicesTop.push(i,i+1,0);indicesBottom.push(bo+i+1,bo+i,bo+0)}for(let i=0;i<segments;i++){const io=i*2;indicesSide.push(so+io,so+io+1,so+io+3);indicesSide.push(so+io,so+io+3,so+io+2)}indicesTop.push(indicesTop[indicesTop.length-1],1,0);indicesBottom.push(bo+1,indicesBottom[indicesBottom.length-1],bo+0);const geometry=new Geometry;geometry.indices=makeUint32Attribute(indicesTop.concat(indicesBottom).concat(indicesSide));geometry.attributes["position"]=makeFloat32Attribute(verticesTop.concat(verticesBottom).concat(verticesSide),3);geometry.attributes["normal"]=makeFloat32Attribute(normalsTop.concat(normalsBottom).concat(normalsSide),3);geometry.attributes["uv"]=makeFloat32Attribute(uvsTop.concat(uvsBottom).concat(uvsSide),2);return geometry}function diskGeometry(radius=.5,segments=8,thetaStart=0,thetaLength=Math.PI*2){const indices=[];const vertices=[];const normals=[];const uvs=[];const vertex=new Vector3;const uv=new Vector2;vertices.push(0,0,0);normals.push(0,0,1);uvs.push(.5,.5);for(let s=0,i=3;s<=segments;s++,i+=3){const segment=thetaStart+s/segments*thetaLength;vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);normals.push(0,0,1);uv.x=(vertices[i]/radius+1)/2;uv.y=(vertices[i+1]/radius+1)/2;uvs.push(uv.x,uv.y)}for(let i=1;i<=segments;i++){indices.push(i,i+1,0)}indices.push(indices[indices.length-1],1,0);const geometry=new Geometry;geometry.indices=makeUint32Attribute(indices);geometry.attributes["position"]=makeFloat32Attribute(vertices,3);geometry.attributes["normal"]=makeFloat32Attribute(normals,3);geometry.attributes["uv"]=makeFloat32Attribute(uvs,2);return geometry}function passGeometry(min=new Vector2(-1,-1),max=new Vector2(1,1)){const geometry=new Geometry;geometry.indices=makeUint32Attribute([0,1,2,0,2,3]);geometry.attributes["position"]=makeFloat32Attribute([min.x,min.y,min.x,max.y,max.x,max.y,max.x,min.y],2);geometry.attributes["uv"]=makeFloat32Attribute([0,1,0,0,1,0,1,1],2);geometry.attributes["normal"]=makeFloat32Attribute([0,0,1,0,0,1,0,0,1,0,0,1],3);return geometry}function planeGeometry(width=1,height=1,widthSegments=1,heightSegments=1){const widthHalf=width/2;const heightHalf=height/2;const gridX=Math.floor(widthSegments);const gridY=Math.floor(heightSegments);const gridX1=gridX+1;const gridY1=gridY+1;const segmentWidth=width/gridX;const segmentHeight=height/gridY;const indices=[];const vertices=[];const normals=[];const uvs=[];for(let iy=0;iy<gridY1;iy++){const y=iy*segmentHeight-heightHalf;for(let ix=0;ix<gridX1;ix++){const x=ix*segmentWidth-widthHalf;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX,iy/gridY)}}for(let iy=0;iy<gridY;iy++){for(let ix=0;ix<gridX;ix++){const a=ix+gridX1*iy;const b=ix+gridX1*(iy+1);const c=ix+1+gridX1*(iy+1);const d=ix+1+gridX1*iy;indices.push(a,b,d);indices.push(b,c,d)}}const geometry=new Geometry;geometry.indices=makeUint32Attribute(indices);geometry.attributes["position"]=makeFloat32Attribute(vertices,3);geometry.attributes["normal"]=makeFloat32Attribute(normals,3);geometry.attributes["uv"]=makeFloat32Attribute(uvs,2);return geometry}function tetrahedronGeometry(radius=1,detail=0){const vertices=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];const indices=[2,1,0,0,3,2,1,3,0,2,3,1];return polyhedronGeometry(vertices,indices,radius,detail)}function octahedronGeometry(radius=1,detail=0){const vertices=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];const indices=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];return polyhedronGeometry(vertices,indices,radius,detail)}function icosahedronGeometry(radius=1,detail=0){const t=(1+Math.sqrt(5))/2;const vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];const indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];return polyhedronGeometry(vertices,indices,radius,detail)}function dodecahedronGeometry(radius=1,detail=0){const t=(1+Math.sqrt(5))/2;const r=1/t;const vertices=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-t,0,-r,t,0,r,-t,0,r,t,-r,-t,0,-r,t,0,r,-t,0,r,t,0,-t,0,-r,t,0,-r,-t,0,r,t,0,r];const indices=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];return polyhedronGeometry(vertices,indices,radius,detail)}function polyhedronGeometry(vertices,indices,radius=1,detail=0){const vertexBuffer=[];const uvBuffer=[];subdivide(detail);applyRadius(radius);generateUVs();const geometry=new Geometry;geometry.attributes["position"]=makeFloat32Attribute(vertexBuffer,3);geometry.attributes["normal"]=makeFloat32Attribute(vertexBuffer.slice(),3);geometry.attributes["uv"]=makeFloat32Attribute(uvBuffer,2);computeVertexNormals(geometry);function subdivide(detail){const a=new Vector3;const b=new Vector3;const c=new Vector3;for(let i=0;i<indices.length;i+=3){getVertexByIndex(indices[i+0],a);getVertexByIndex(indices[i+1],b);getVertexByIndex(indices[i+2],c);subdivideFace(a,b,c,detail)}}function subdivideFace(a,b,c,detail){const cols=Math.pow(2,detail);const v=[];for(let i=0;i<=cols;i++){v[i]=[];const aj=a.clone().lerp(c,i/cols);const bj=b.clone().lerp(c,i/cols);const rows=cols-i;for(let j=0;j<=rows;j++){if(j===0&&i===cols){v[i][j]=aj}else{v[i][j]=aj.clone().lerp(bj,j/rows)}}}for(let i=0;i<cols;i++){for(let j=0;j<2*(cols-i)-1;j++){const k=Math.floor(j/2);if(j%2===0){pushVertex(v[i][k+1]);pushVertex(v[i+1][k]);pushVertex(v[i][k])}else{pushVertex(v[i][k+1]);pushVertex(v[i+1][k+1]);pushVertex(v[i+1][k])}}}}function applyRadius(radius){const vertex=new Vector3;for(let i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];vertex.normalize().multiplyByScalar(radius);vertexBuffer[i+0]=vertex.x;vertexBuffer[i+1]=vertex.y;vertexBuffer[i+2]=vertex.z}}function generateUVs(){const vertex=new Vector3;for(let i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];const u=azimuth(vertex)/2/Math.PI+.5;const v=inclination(vertex)/Math.PI+.5;uvBuffer.push(u,1-v)}correctUVs();correctSeam()}function correctSeam(){for(let i=0;i<uvBuffer.length;i+=6){const x0=uvBuffer[i+0];const x1=uvBuffer[i+2];const x2=uvBuffer[i+4];const max=Math.max(x0,x1,x2);const min=Math.min(x0,x1,x2);if(max>.9&&min<.1){if(x0<.2){uvBuffer[i+0]+=1}if(x1<.2){uvBuffer[i+2]+=1}if(x2<.2){uvBuffer[i+4]+=1}}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z)}function getVertexByIndex(index,vertex){const stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2]}function correctUVs(){const a=new Vector3;const b=new Vector3;const c=new Vector3;const centroid=new Vector3;const uvA=new Vector2;const uvB=new Vector2;const uvC=new Vector2;for(let i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).multiplyByScalar(1/3);const azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi)}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+.5}}function azimuth(vector){return Math.atan2(vector.z,-vector.x)}function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z))}return geometry}exports.Attribute=Attribute;exports.AttributeData=AttributeData;exports.Geometry=Geometry;exports.boxGeometry=boxGeometry;exports.computeVertexNormals=computeVertexNormals;exports.convertToInterleavedGeometry=convertToInterleavedGeometry;exports.cylinderGeometry=cylinderGeometry;exports.diskGeometry=diskGeometry;exports.dodecahedronGeometry=dodecahedronGeometry;exports.fetchOBJ=fetchOBJ;exports.icosahedronGeometry=icosahedronGeometry;exports.makeFloat32Attribute=makeFloat32Attribute;exports.makeInt16Attribute=makeInt16Attribute;exports.makeInt32Attribute=makeInt32Attribute;exports.makeUint32Attribute=makeUint32Attribute;exports.makeUint8Attribute=makeUint8Attribute;exports.octahedronGeometry=octahedronGeometry;exports.parseOBJ=parseOBJ;exports.passGeometry=passGeometry;exports.planeGeometry=planeGeometry;exports.polyhedronGeometry=polyhedronGeometry;exports.tetrahedronGeometry=tetrahedronGeometry;exports.transformGeometry=transformGeometry;return exports})({},__);