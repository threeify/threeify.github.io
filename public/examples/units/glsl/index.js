(function(){"use strict";const arrayBuffer=new ArrayBuffer(12*16);const floatArray=new Float32Array(arrayBuffer);const intArray=new Int32Array(arrayBuffer);function hashFloat2(v0,v1){floatArray[0]=v0;floatArray[1]=v1;const hash=intArray[0];return hash*397^intArray[1]}function hashFloat3(v0,v1,v2){floatArray[0]=v0;floatArray[1]=v1;floatArray[2]=v2;let hash=intArray[0]|0;hash=hash*397^(intArray[1]|0);return hash*397^(intArray[2]|0)}function hashFloatArray(elements){for(let i=0;i<elements.length;i++){floatArray[i]=elements[i]}let hash=intArray[0]|0;for(let i=1;i<16;i++){hash=hash*397^(intArray[i]|0)}return hash}function clamp(value,min,max){return Math.min(Math.max(value,min),max)}function isPow2(value){return(value&value-1)===0&&value!==0}class Vector2{constructor(x=0,y=0){this.x=x;this.y=y}get width(){return this.x}set width(width){this.x=width}get height(){return this.y}set height(height){this.y=height}getHashCode(){return hashFloat2(this.x,this.y)}set(x,y){this.x=x;this.y=y;return this}clone(){return(new Vector2).copy(this)}copy(v){return this.set(v.x,v.y)}add(v){this.x+=v.x;this.y+=v.y;return this}addScalar(s){this.x+=s;this.y+=s;return this}sub(v){this.x-=v.x;this.y-=v.y;return this}multiplyByScalar(s){this.x*=s;this.y*=s;return this}negate(){this.x*=-1;this.y*=-1;return this}normalize(){const length=this.length();return this.multiplyByScalar(length===0?1:0)}getComponent(index){if(index===0){return this.x}else if(index===1){return this.y}else{throw new Error(`index of our range: ${index}`)}}setComponent(index,value){if(index===0){this.x=value}else if(index===1){this.y=value}else{throw new Error(`index of our range: ${index}`)}return this}dot(v){return this.x*v.x+this.y*v.y}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x*this.x+this.y*this.y}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this}clamp(min,max){this.x=clamp(this.x,min.x,max.x);this.y=clamp(this.y,min.y,max.y);return this}equals(v){return v.x===this.x&&v.y===this.y}setFromArray(array,offset){this.x=array[offset+0];this.y=array[offset+1]}toArray(array,offset){array[offset+0]=this.x;array[offset+1]=this.y}}const GL=WebGLRenderingContext;var ComponentType;(function(ComponentType){ComponentType[ComponentType["Byte"]=GL.BYTE]="Byte";ComponentType[ComponentType["UnsignedByte"]=GL.UNSIGNED_BYTE]="UnsignedByte";ComponentType[ComponentType["Short"]=GL.SHORT]="Short";ComponentType[ComponentType["UnsignedShort"]=GL.UNSIGNED_SHORT]="UnsignedShort";ComponentType[ComponentType["Int"]=GL.INT]="Int";ComponentType[ComponentType["UnsignedInt"]=GL.UNSIGNED_INT]="UnsignedInt";ComponentType[ComponentType["Float"]=GL.FLOAT]="Float"})(ComponentType||(ComponentType={}));function componentTypeSizeOf(componentType){switch(componentType){case ComponentType.Byte:case ComponentType.UnsignedByte:return 1;case ComponentType.Short:case ComponentType.UnsignedShort:return 2;case ComponentType.Float:case ComponentType.Int:case ComponentType.UnsignedInt:return 4}throw new Error(`unsupported component type: ${componentType}`)}const _lut=[];for(let i=0;i<256;i++){_lut[i]=(i<16?"0":"")+i.toString(16)}function generateUUID(){const d0=Math.random()*4294967296|0;const d1=Math.random()*4294967296|0;const d2=Math.random()*4294967296|0;const d3=Math.random()*4294967296|0;const uuid=_lut[d0&255]+_lut[d0>>8&255]+_lut[d0>>16&255]+_lut[d0>>24&255]+"-"+_lut[d1&255]+_lut[d1>>8&255]+"-"+_lut[d1>>16&15|64]+_lut[d1>>24&255]+"-"+_lut[d2&63|128]+_lut[d2>>8&255]+"-"+_lut[d2>>16&255]+_lut[d2>>24&255]+_lut[d3&255]+_lut[d3>>8&255]+_lut[d3>>16&255]+_lut[d3>>24&255];return uuid.toUpperCase()}var BufferTarget;(function(BufferTarget){BufferTarget[BufferTarget["Array"]=GL.ARRAY_BUFFER]="Array";BufferTarget[BufferTarget["ElementArray"]=GL.ELEMENT_ARRAY_BUFFER]="ElementArray"})(BufferTarget||(BufferTarget={}));class AttributeData{constructor(arrayBuffer,target=BufferTarget.Array){this.arrayBuffer=arrayBuffer;this.target=target;this.disposed=false;this.uuid=generateUUID();this.version=0}dirty(){this.version++}dispose(){if(!this.disposed){this.disposed=true;this.dirty()}}}class Attribute{constructor(attributeData,componentsPerVertex,componentType,vertexStride,byteOffset,normalized){this.attributeData=attributeData;this.componentsPerVertex=componentsPerVertex;this.componentType=componentType;this.vertexStride=vertexStride;this.byteOffset=byteOffset;this.normalized=normalized;this.bytesPerComponent=componentTypeSizeOf(this.componentType);this.bytesPerVertex=this.bytesPerComponent*this.componentsPerVertex;if(this.vertexStride<0){this.vertexStride=this.bytesPerVertex}this.count=this.attributeData.arrayBuffer.byteLength/this.vertexStride}}function makeUint32Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Uint32Array?array:new Uint32Array(array)).buffer),componentsPerVertex,ComponentType.UnsignedInt,-1,0,normalized)}function makeFloat32Attribute(array,componentsPerVertex=1,normalized=false){return new Attribute(new AttributeData((array instanceof Float32Array?array:new Float32Array(array)).buffer),componentsPerVertex,ComponentType.Float,-1,0,normalized)}var PrimitiveType;(function(PrimitiveType){PrimitiveType[PrimitiveType["Points"]=GL.POINTS]="Points";PrimitiveType[PrimitiveType["Lines"]=GL.LINES]="Lines";PrimitiveType[PrimitiveType["LineStrip"]=GL.LINE_STRIP]="LineStrip";PrimitiveType[PrimitiveType["Triangles"]=GL.TRIANGLES]="Triangles";PrimitiveType[PrimitiveType["TriangleFan"]=GL.TRIANGLE_FAN]="TriangleFan";PrimitiveType[PrimitiveType["TriangleStrip"]=GL.TRIANGLE_STRIP]="TriangleStrip"})(PrimitiveType||(PrimitiveType={}));class Geometry{constructor(){this.disposed=false;this.version=0;this.indices=undefined;this.attributes={};this.primitive=PrimitiveType.Triangles}dirty(){this.version++}dispose(){if(!this.disposed){for(const name in this.attributes){const attribute=this.attributes[name];if(attribute!==undefined){attribute.attributeData.dispose()}}this.disposed=true;this.dirty()}}}function passGeometry(min=new Vector2(-1,-1),max=new Vector2(1,1)){const geometry=new Geometry;geometry.indices=makeUint32Attribute([0,1,2,0,2,3]);geometry.attributes["position"]=makeFloat32Attribute([min.x,min.y,min.x,max.y,max.x,max.y,max.x,min.y],2);geometry.attributes["uv"]=makeFloat32Attribute([0,1,0,0,1,0,1,1],2);geometry.attributes["normal"]=makeFloat32Attribute([0,0,1,0,0,1,0,0,1,0,0,1],3);return geometry}class ShaderMaterial{constructor(vertexShaderCode,fragmentShaderCode,glslVersion=200){this.vertexShaderCode=vertexShaderCode;this.fragmentShaderCode=fragmentShaderCode;this.glslVersion=glslVersion;this.uuid=generateUUID();this.version=0;this.disposed=false;this.name=""}dirty(){this.version++}dispose(){this.disposed=true;this.dirty()}}class Vector3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}get width(){return this.x}set width(width){this.x=width}get height(){return this.y}set height(height){this.y=height}get depth(){return this.z}set depth(depth){this.z=depth}get r(){return this.x}set r(r){this.x=r}get g(){return this.y}set g(g){this.y=g}get b(){return this.z}set b(b){this.z=b}getHashCode(){return hashFloat3(this.x,this.y,this.z)}set(x,y,z){this.x=x;this.y=y;this.z=z;return this}clone(){return(new Vector3).copy(this)}copy(v){return this.set(v.x,v.y,v.z)}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this}multiplyByScalar(s){this.x*=s;this.y*=s;this.z*=s;return this}negate(){this.x*=-1;this.y*=-1;this.z*=-1;return this}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this}normalize(){const length=this.length();return this.multiplyByScalar(length===0?1:1/length)}getComponent(index){if(index===0){return this.x}else if(index===1){return this.y}else if(index===2){return this.z}else{throw new Error(`index of our range: ${index}`)}}setComponent(index,value){if(index===0){this.x=value}else if(index===1){this.y=value}else if(index===2){this.z=value}else{throw new Error(`index of our range: ${index}`)}return this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z}cross(v){const ax=this.x,ay=this.y,az=this.z;const bx=v.x,by=v.y,bz=v.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}distanceToSquared(v){const dx=this.x-v.x;const dy=this.y-v.y;const dz=this.z-v.z;return dx*dx+dy*dy+dz*dz}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this}clamp(min,max){this.x=clamp(this.x,min.x,max.x);this.y=clamp(this.y,min.y,max.y);this.z=clamp(this.z,min.z,max.z);return this}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z}setFromArray(array,offset){this.x=array[offset+0];this.y=array[offset+1];this.z=array[offset+2]}toArray(array,offset){array[offset+0]=this.x;array[offset+1]=this.y;array[offset+2]=this.z}}var BufferUsage;(function(BufferUsage){BufferUsage[BufferUsage["StaticDraw"]=GL.STATIC_DRAW]="StaticDraw";BufferUsage[BufferUsage["DynamicDraw"]=GL.DYNAMIC_DRAW]="DynamicDraw"})(BufferUsage||(BufferUsage={}));class Buffer{constructor(context,arrayBuffer,target=BufferTarget.Array,usage=BufferUsage.StaticDraw){this.context=context;this.target=target;this.usage=usage;this.disposed=false;const gl=context.gl;{const glBuffer=gl.createBuffer();if(glBuffer===null){throw new Error("createBuffer failed")}this.glBuffer=glBuffer}gl.bindBuffer(this.target,this.glBuffer);gl.bufferData(this.target,arrayBuffer,this.usage);this.id=this.context.registerResource(this)}update(arrayBuffer,target=BufferTarget.Array,usage=BufferUsage.StaticDraw){this.target=target;this.usage=usage;const gl=this.context.gl;gl.bindBuffer(this.target,this.glBuffer);gl.bufferData(this.target,arrayBuffer,this.usage)}dispose(){if(!this.disposed){this.context.gl.deleteBuffer(this.glBuffer);this.context.disposeResource(this);this.disposed=true}}}class BufferAccessor{constructor(buffer,componentType,componentsPerVertex,normalized,vertexStride,byteOffset){this.buffer=buffer;this.componentType=componentType;this.componentsPerVertex=componentsPerVertex;this.normalized=normalized;this.vertexStride=vertexStride;this.byteOffset=byteOffset}}function makeBufferAccessorFromAttribute(context,attribute,bufferTarget=undefined){const attributeData=attribute.attributeData;const target=bufferTarget!==undefined?bufferTarget:attributeData.target;const buffer=new Buffer(context,attributeData.arrayBuffer,target);const bufferAccessor=new BufferAccessor(buffer,attribute.componentType,attribute.componentsPerVertex,attribute.normalized,attribute.vertexStride,attribute.byteOffset);return bufferAccessor}class BufferGeometry{constructor(context){this.context=context;this.disposed=false;this.bufferAccessors={};this.indices=undefined;this.primitive=PrimitiveType.Triangles;this.count=-1}dispose(){console.warn("This is not safe.  The buffers may be used by multiple bufferViews & bufferGeometries.");if(!this.disposed){for(const name in this.bufferAccessors){const bufferAccessor=this.bufferAccessors[name];if(bufferAccessor!==undefined){bufferAccessor.buffer.dispose()}}if(this.indices!==undefined){this.indices.buffer.dispose()}this.disposed=true}}}function makeBufferGeometryFromGeometry(context,geometry){const bufferGeometry=new BufferGeometry(context);if(geometry.indices!==undefined){bufferGeometry.indices=makeBufferAccessorFromAttribute(context,geometry.indices,BufferTarget.ElementArray);bufferGeometry.count=geometry.indices.count}for(const name in geometry.attributes){const attribute=geometry.attributes[name];if(attribute!==undefined){bufferGeometry.bufferAccessors[name]=makeBufferAccessorFromAttribute(context,attribute);if(bufferGeometry.count===-1){bufferGeometry.count=attribute.count}}}bufferGeometry.primitive=geometry.primitive;return bufferGeometry}class ClearState{constructor(color=new Vector3(1,1,1),alpha=0,depth=1,stencil=0){this.color=color;this.alpha=alpha;this.depth=depth;this.stencil=stencil}clone(){return new ClearState(this.color,this.alpha,this.depth,this.stencil)}copy(cs){this.color.copy(cs.color);this.alpha=cs.alpha;this.depth=cs.depth;this.stencil=cs.stencil}equals(cs){return this.color.equals(cs.color)&&this.alpha===cs.alpha&&this.depth===cs.depth&&this.stencil===cs.stencil}}var DepthTestFunc;(function(DepthTestFunc){DepthTestFunc[DepthTestFunc["Never"]=GL.NEVER]="Never";DepthTestFunc[DepthTestFunc["Less"]=GL.LESS]="Less";DepthTestFunc[DepthTestFunc["Equal"]=GL.EQUAL]="Equal";DepthTestFunc[DepthTestFunc["LessOrEqual"]=GL.LEQUAL]="LessOrEqual";DepthTestFunc[DepthTestFunc["Greater"]=GL.GREATER]="Greater";DepthTestFunc[DepthTestFunc["NotEqual"]=GL.NOTEQUAL]="NotEqual";DepthTestFunc[DepthTestFunc["GreaterOrEqual"]=GL.GEQUAL]="GreaterOrEqual";DepthTestFunc[DepthTestFunc["Always"]=GL.ALWAYS]="Always"})(DepthTestFunc||(DepthTestFunc={}));class DepthTestState{constructor(enabled=false,func=DepthTestFunc.Less){this.enabled=enabled;this.func=func}clone(){return new DepthTestState(this.enabled,this.func)}copy(dts){this.enabled=dts.enabled;this.func=dts.func}equals(dts){return this.enabled===dts.enabled&&this.func===dts.func}}var Attachment;(function(Attachment){Attachment[Attachment["Color0"]=GL.COLOR_ATTACHMENT0]="Color0";Attachment[Attachment["Depth"]=GL.DEPTH_ATTACHMENT]="Depth";Attachment[Attachment["DepthStencil"]=GL.DEPTH_STENCIL_ATTACHMENT]="DepthStencil";Attachment[Attachment["Stencil"]=GL.STENCIL_ATTACHMENT]="Stencil"})(Attachment||(Attachment={}));var BufferBit;(function(BufferBit){BufferBit[BufferBit["None"]=0]="None";BufferBit[BufferBit["Color"]=GL.COLOR_BUFFER_BIT]="Color";BufferBit[BufferBit["Depth"]=GL.DEPTH_BUFFER_BIT]="Depth";BufferBit[BufferBit["Stencil"]=GL.STENCIL_BUFFER_BIT]="Stencil";BufferBit[BufferBit["Default"]=BufferBit.Color|BufferBit.Depth]="Default";BufferBit[BufferBit["All"]=BufferBit.Color|BufferBit.Depth|BufferBit.Stencil]="All"})(BufferBit||(BufferBit={}));var DataType;(function(DataType){DataType[DataType["Byte"]=GL.BYTE]="Byte";DataType[DataType["UnsignedByte"]=GL.UNSIGNED_BYTE]="UnsignedByte";DataType[DataType["Short"]=GL.SHORT]="Short";DataType[DataType["UnsignedShort"]=GL.UNSIGNED_SHORT]="UnsignedShort";DataType[DataType["Int"]=GL.INT]="Int";DataType[DataType["UnsignedInt"]=GL.UNSIGNED_INT]="UnsignedInt";DataType[DataType["Float"]=GL.FLOAT]="Float"})(DataType||(DataType={}));function sizeOfDataType(dataType){switch(dataType){case DataType.Byte:case DataType.UnsignedByte:return 1;case DataType.Short:case DataType.UnsignedShort:return 2;case DataType.Int:case DataType.UnsignedInt:case DataType.Float:return 5}throw new Error(`unsupported data type: ${dataType}`)}var PixelFormat;(function(PixelFormat){PixelFormat[PixelFormat["RGBA"]=GL.RGBA]="RGBA";PixelFormat[PixelFormat["RGB"]=GL.RGB]="RGB";PixelFormat[PixelFormat["LuminanceAlpha"]=GL.LUMINANCE_ALPHA]="LuminanceAlpha";PixelFormat[PixelFormat["Luminance"]=GL.LUMINANCE]="Luminance";PixelFormat[PixelFormat["Alpha"]=GL.ALPHA]="Alpha";PixelFormat[PixelFormat["DepthComponent"]=GL.DEPTH_COMPONENT]="DepthComponent";PixelFormat[PixelFormat["DepthStencil"]=GL.DEPTH_STENCIL]="DepthStencil"})(PixelFormat||(PixelFormat={}));function numPixelFormatComponents(pixelFormat){switch(pixelFormat){case PixelFormat.Alpha:case PixelFormat.Luminance:case PixelFormat.DepthComponent:return 1;case PixelFormat.LuminanceAlpha:case PixelFormat.DepthStencil:return 2;case PixelFormat.RGB:return 3;case PixelFormat.RGBA:return 4}throw new Error(`unsupported pixel format: ${pixelFormat}`)}var PixelEncoding;(function(PixelEncoding){PixelEncoding[PixelEncoding["Linear"]=0]="Linear";PixelEncoding[PixelEncoding["sRGB"]=1]="sRGB";PixelEncoding[PixelEncoding["RGBE"]=2]="RGBE";PixelEncoding[PixelEncoding["RGBD"]=3]="RGBD"})(PixelEncoding||(PixelEncoding={}));class ArrayBufferImage{constructor(data,width,height,dataType=DataType.UnsignedByte,pixelEncoding=PixelEncoding.sRGB){this.data=data;this.width=width;this.height=height;this.dataType=dataType;this.pixelEncoding=pixelEncoding}}class Matrix4{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}getHashCode(){return hashFloatArray(this.elements)}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this}clone(){return(new Matrix4).copy(this)}copy(m){const me=m.elements;return this.set(me[0],me[4],me[8],me[12],me[1],me[5],me[9],me[13],me[2],me[6],me[10],me[14],me[3],me[7],me[11],me[15])}getComponent(index){return this.elements[index]}setComponent(index,value){this.elements[index]=value;return this}multiplyByScalar(s){const te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this}makeIdentity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}equals(m){for(let i=0;i<16;i++){if(m.elements[i]!==this.elements[i]){return false}}return true}setFromArray(array,offset){for(let i=0;i<this.elements.length;i++){this.elements[i]=array[offset+i]}}toArray(array,offset){for(let i=0;i<this.elements.length;i++){array[offset+i]=this.elements[i]}}}var EulerOrder;(function(EulerOrder){EulerOrder[EulerOrder["XYZ"]=0]="XYZ";EulerOrder[EulerOrder["YXZ"]=1]="YXZ";EulerOrder[EulerOrder["ZXY"]=2]="ZXY";EulerOrder[EulerOrder["ZYX"]=3]="ZYX";EulerOrder[EulerOrder["YZX"]=4]="YZX";EulerOrder[EulerOrder["XZY"]=5]="XZY";EulerOrder[EulerOrder["Default"]=0]="Default"})(EulerOrder||(EulerOrder={}));var TextureFilter;(function(TextureFilter){TextureFilter[TextureFilter["LinearMipmapLinear"]=GL.LINEAR_MIPMAP_LINEAR]="LinearMipmapLinear";TextureFilter[TextureFilter["LinearMipmapNearest"]=GL.LINEAR_MIPMAP_NEAREST]="LinearMipmapNearest";TextureFilter[TextureFilter["Linear"]=GL.LINEAR]="Linear";TextureFilter[TextureFilter["Nearest"]=GL.NEAREST]="Nearest";TextureFilter[TextureFilter["NearestMipmapLinear"]=GL.NEAREST_MIPMAP_LINEAR]="NearestMipmapLinear";TextureFilter[TextureFilter["NearestMipmapNearest"]=GL.NEAREST_MIPMAP_NEAREST]="NearestMipmapNearest"})(TextureFilter||(TextureFilter={}));var TextureTarget;(function(TextureTarget){TextureTarget[TextureTarget["Texture2D"]=GL.TEXTURE_2D]="Texture2D";TextureTarget[TextureTarget["TextureCubeMap"]=GL.TEXTURE_CUBE_MAP]="TextureCubeMap";TextureTarget[TextureTarget["CubeMapPositiveX"]=GL.TEXTURE_CUBE_MAP_POSITIVE_X]="CubeMapPositiveX";TextureTarget[TextureTarget["CubeMapNegativeX"]=GL.TEXTURE_CUBE_MAP_NEGATIVE_X]="CubeMapNegativeX";TextureTarget[TextureTarget["CubeMapPositiveY"]=GL.TEXTURE_CUBE_MAP_POSITIVE_Y]="CubeMapPositiveY";TextureTarget[TextureTarget["CubeMapNegativeY"]=GL.TEXTURE_CUBE_MAP_NEGATIVE_Y]="CubeMapNegativeY";TextureTarget[TextureTarget["CubeMapPositiveZ"]=GL.TEXTURE_CUBE_MAP_POSITIVE_Z]="CubeMapPositiveZ";TextureTarget[TextureTarget["CubeMapNegativeZ"]=GL.TEXTURE_CUBE_MAP_NEGATIVE_Z]="CubeMapNegativeZ"})(TextureTarget||(TextureTarget={}));const cubeFaceTargets=[TextureTarget.CubeMapPositiveX,TextureTarget.CubeMapNegativeX,TextureTarget.CubeMapPositiveY,TextureTarget.CubeMapNegativeY,TextureTarget.CubeMapPositiveZ,TextureTarget.CubeMapNegativeZ];class Box2{constructor(min=new Vector2(+Infinity,+Infinity),max=new Vector2(+Infinity,+Infinity)){this.min=min;this.max=max}get x(){return this.min.x}get y(){return this.min.y}get left(){return this.min.x}get top(){return this.min.y}get width(){return this.max.x-this.min.x}get height(){return this.max.y-this.min.y}get bottom(){return this.max.y}get right(){return this.max.x}getHashCode(){return hashFloat2(this.min.getHashCode(),this.max.getHashCode())}set(min,max){this.min.copy(min);this.max.copy(max);return this}clone(){return(new Box2).copy(this)}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this}getCenter(v){return v.set((this.min.x+this.max.x)*.5,(this.min.y+this.max.y)*.5)}makeEmpty(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}union(box){this.min.min(box.min);this.max.max(box.max);return this}translate(offset){this.min.add(offset);this.max.add(offset);return this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}}class VirtualFramebuffer{constructor(context){this.context=context;this.disposed=false;this.cullingState=undefined;this.clearState=undefined;this.depthTestState=undefined;this.blendState=undefined;this.maskState=undefined;this.viewport=undefined}clear(attachmentBits=BufferBit.Color|BufferBit.Depth,clearState=undefined){var _a;this.context.framebuffer=this;this.context.clearState=(_a=clearState!==null&&clearState!==void 0?clearState:this.clearState)!==null&&_a!==void 0?_a:this.context.clearState;const gl=this.context.gl;gl.clear(attachmentBits)}render(node,camera,clear=false){this.context.framebuffer=this;if(clear){this.clear()}this.context.render(node,camera)}flush(){this.context.gl.flush()}finish(){this.context.gl.finish()}}function renderBufferGeometry(framebuffer,program,uniforms,bufferGeometry,depthTestState=undefined,blendState=undefined,maskState=undefined,cullingState=undefined){var _a,_b,_c,_d;const context=framebuffer.context;context.framebuffer=framebuffer;context.blendState=(_a=blendState!==null&&blendState!==void 0?blendState:framebuffer.blendState)!==null&&_a!==void 0?_a:context.blendState;context.depthTestState=(_b=depthTestState!==null&&depthTestState!==void 0?depthTestState:framebuffer.depthTestState)!==null&&_b!==void 0?_b:context.depthTestState;context.maskState=(_c=maskState!==null&&maskState!==void 0?maskState:framebuffer.maskState)!==null&&_c!==void 0?_c:context.maskState;context.cullingState=(_d=cullingState!==null&&cullingState!==void 0?cullingState:framebuffer.cullingState)!==null&&_d!==void 0?_d:context.cullingState;context.program=program;context.program.setUniformValues(uniforms);context.program.setAttributeBuffers(bufferGeometry);context.viewport=new Box2(new Vector2,framebuffer.size);const gl=context.gl;if(bufferGeometry.indices!==undefined){gl.drawElements(bufferGeometry.primitive,bufferGeometry.count,bufferGeometry.indices.componentType,0)}else{gl.drawArrays(bufferGeometry.primitive,0,bufferGeometry.count)}}var ShaderType;(function(ShaderType){ShaderType[ShaderType["Fragment"]=GL.FRAGMENT_SHADER]="Fragment";ShaderType[ShaderType["Vertex"]=GL.VERTEX_SHADER]="Vertex"})(ShaderType||(ShaderType={}));var __classPrivateFieldGet=undefined&&undefined.__classPrivateFieldGet||function(receiver,privateMap){if(!privateMap.has(receiver)){throw new TypeError("attempted to get private field on non-instance")}return privateMap.get(receiver)};var __classPrivateFieldSet=undefined&&undefined.__classPrivateFieldSet||function(receiver,privateMap,value){if(!privateMap.has(receiver)){throw new TypeError("attempted to set private field on non-instance")}privateMap.set(receiver,value);return value};var _validated;function insertLineNumbers(source){const inputLines=source.split("\n");const outputLines=["\n"];const maxLineCharacters=Math.floor(Math.log10(inputLines.length));for(let l=0;l<inputLines.length;l++){const lAsString=`000000${l+1}`.slice(-maxLineCharacters-1);outputLines.push(`${lAsString}: ${inputLines[l]}`)}return outputLines.join("\n")}function removeDeadCode(source){const defineRegexp=/^#define +([\w\d_]+)/;const undefRegexp=/^#undef +([\w\d_]+)/;const ifdefRegexp=/^#ifdef +([\w\d_]+)/;const ifndefRegexp=/^#ifndef +([\w\d_]+)/;const endifRegexp=/^#endif.* /;let defines=[];const liveCodeStack=[true];const outputLines=[];source.split("\n").forEach(line=>{const isLive=liveCodeStack[liveCodeStack.length-1];if(isLive){const defineMatch=line.match(defineRegexp);if(defineMatch!==null){defines.push(defineMatch[1])}const undefMatch=line.match(undefRegexp);if(undefMatch!==null){const indexOfDefine=defines.indexOf(undefMatch[1]);if(indexOfDefine>=0){defines=defines.splice(indexOfDefine,1)}}const ifdefMatch=line.match(ifdefRegexp);if(ifdefMatch!==null){liveCodeStack.push(defines.indexOf(ifdefMatch[1])>=0);return}const ifndefMatch=line.match(ifndefRegexp);if(ifndefMatch!==null){liveCodeStack.push(defines.indexOf(ifndefMatch[1])<0);return}}const endifMatch=line.match(endifRegexp);if(endifMatch!==null){liveCodeStack.pop();return}if(isLive){outputLines.push(line)}});return outputLines.join("\n").replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm,"").replace(/[\r\n]+/g,"\n")}class Shader{constructor(context,source,shaderType,glslVersion=300){this.context=context;this.source=source;this.shaderType=shaderType;this.glslVersion=glslVersion;this.disposed=false;_validated.set(this,false);const gl=this.context.gl;{const glShader=gl.createShader(shaderType);if(glShader===null){throw new Error("createShader failed")}this.glShader=glShader}const prefix=[];if(glslVersion===300){prefix.push("#version 300 es")}if(shaderType===ShaderType.Fragment){const glxo=context.glxo;if(glxo.EXT_shader_texture_lod!==null){prefix.push("#extension GL_EXT_shader_texture_lod : enable")}prefix.push("#extension GL_OES_standard_derivatives : enable")}const combinedSource=prefix.join("\n")+"\n"+source;this.finalSource=removeDeadCode(combinedSource);gl.shaderSource(this.glShader,this.finalSource);gl.compileShader(this.glShader);this.id=this.context.registerResource(this)}get translatedSource(){const ds=this.context.glxo.WEBGL_debug_shaders;if(ds!==null){return ds.getTranslatedShaderSource(this.glShader)}return""}validate(){if(__classPrivateFieldGet(this,_validated)||this.disposed){return}const gl=this.context.gl;const compileStatus=gl.getShaderParameter(this.glShader,GL.COMPILE_STATUS);if(!compileStatus){const infoLog=gl.getShaderInfoLog(this.glShader);const errorMessage=`could not compile shader:\n${infoLog}`;console.error(errorMessage);console.error(insertLineNumbers(this.finalSource));this.disposed=true;throw new Error(errorMessage)}__classPrivateFieldSet(this,_validated,true)}dispose(){if(!this.disposed){this.context.gl.deleteShader(this.glShader);this.context.disposeResource(this);this.disposed=true}}}_validated=new WeakMap;class VertexArrayObject{constructor(program,bufferGeometry){this.program=program;this.disposed=false;this.primitive=PrimitiveType.Triangles;this.offset=0;this.count=-1;this.primitive=bufferGeometry.primitive;this.count=bufferGeometry.count;const glxVAO=this.program.context.glx.OES_vertex_array_object;{const vao=glxVAO.createVertexArrayOES();if(vao===null){throw new Error("createVertexArray failed")}this.glVertexArrayObject=vao}glxVAO.bindVertexArrayOES(this.glVertexArrayObject);program.setAttributeBuffers(bufferGeometry);this.id=this.program.context.registerResource(this)}dispose(){if(!this.disposed){const glxVAO=this.program.context.glx.OES_vertex_array_object;glxVAO.deleteVertexArrayOES(this.glVertexArrayObject);this.program.context.disposeResource(this);this.disposed=true}}}class ProgramAttribute{constructor(program,index){this.program=program;this.index=index;this.name=name;const gl=program.context.gl;{const activeInfo=gl.getActiveAttrib(program.glProgram,index);if(activeInfo===null){throw new Error(`can not find attribute with index: ${index}`)}this.name=activeInfo.name;this.size=activeInfo.size;this.type=activeInfo.type;const glLocation=gl.getAttribLocation(program.glProgram,this.name);if(glLocation<0){throw new Error(`can not find attribute named: ${this.name}`)}this.glLocation=glLocation}}setBuffer(bufferAccessor){const gl=this.program.context.gl;gl.enableVertexAttribArray(this.glLocation);gl.bindBuffer(GL.ARRAY_BUFFER,bufferAccessor.buffer.glBuffer);gl.vertexAttribPointer(this.glLocation,bufferAccessor.componentsPerVertex,bufferAccessor.componentType,bufferAccessor.normalized,bufferAccessor.vertexStride,bufferAccessor.byteOffset);return this}}function linearizeVector2FloatArray(array){const result=new Float32Array(array.length*2);for(let i=0;i<array.length;i++){array[i].toArray(result,i*2)}return result}function linearizeVector3FloatArray(array){const result=new Float32Array(array.length*3);for(let i=0;i<array.length;i++){array[i].toArray(result,i*3)}return result}function linearizeMatrix3FloatArray(array){const result=new Float32Array(array.length*9);for(let i=0;i<array.length;i++){array[i].toArray(result,i*9)}return result}function linearizeMatrix4FloatArray(array){const result=new Float32Array(array.length*16);for(let i=0;i<array.length;i++){array[i].toArray(result,i*16)}return result}class Matrix3{constructor(){this.elements=[1,0,0,0,1,0,0,0,1]}getHashCode(){return hashFloatArray(this.elements)}set(n11,n12,n13,n21,n22,n23,n31,n32,n33){const te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this}clone(){return(new Matrix3).copy(this)}copy(m){const te=this.elements;const me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this}getComponent(index){return this.elements[index]}setComponent(index,value){this.elements[index]=value;return this}multiplyByScalar(s){const te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this}makeIdentity(){this.set(1,0,0,0,1,0,0,0,1);return this}equals(m){for(let i=0;i<16;i++){if(m.elements[i]!==this.elements[i]){return false}}return true}setFromArray(floatArray,offset){for(let i=0;i<this.elements.length;i++){this.elements[i]=floatArray[offset+i]}}toArray(floatArray,offset){for(let i=0;i<this.elements.length;i++){floatArray[offset+i]=this.elements[i]}}}var UniformType;(function(UniformType){UniformType[UniformType["Bool"]=GL.BOOL]="Bool";UniformType[UniformType["BoolVec2"]=GL.BOOL_VEC2]="BoolVec2";UniformType[UniformType["BoolVec3"]=GL.BOOL_VEC3]="BoolVec3";UniformType[UniformType["BoolVec4"]=GL.BOOL_VEC4]="BoolVec4";UniformType[UniformType["Int"]=GL.INT]="Int";UniformType[UniformType["IntVec2"]=GL.INT_VEC2]="IntVec2";UniformType[UniformType["IntVec3"]=GL.INT_VEC3]="IntVec3";UniformType[UniformType["IntVec4"]=GL.INT_VEC4]="IntVec4";UniformType[UniformType["Float"]=GL.FLOAT]="Float";UniformType[UniformType["FloatVec2"]=GL.FLOAT_VEC2]="FloatVec2";UniformType[UniformType["FloatVec3"]=GL.FLOAT_VEC3]="FloatVec3";UniformType[UniformType["FloatVec4"]=GL.FLOAT_VEC4]="FloatVec4";UniformType[UniformType["FloatMat2"]=GL.FLOAT_MAT2]="FloatMat2";UniformType[UniformType["FloatMat3"]=GL.FLOAT_MAT3]="FloatMat3";UniformType[UniformType["FloatMat4"]=GL.FLOAT_MAT4]="FloatMat4";UniformType[UniformType["Sampler2D"]=GL.SAMPLER_2D]="Sampler2D";UniformType[UniformType["SamplerCube"]=GL.SAMPLER_CUBE]="SamplerCube"})(UniformType||(UniformType={}));function numTextureUnits(uniformType){switch(uniformType){case UniformType.Sampler2D:return 1;case UniformType.SamplerCube:return 1;default:return 0}}const array1dRegexp=/^([a-zA-Z_0-9]+)\[[0-9]+\]$/;class ProgramUniform{constructor(program,index){this.program=program;this.index=index;this.valueHashCode=0xda1fe4b380c9f80;this.textureUnit=-1;this.context=program.context;const gl=program.context.gl;{const activeInfo=gl.getActiveUniform(program.glProgram,index);if(activeInfo===null){throw new Error(`Can not find uniform with index: ${index}`)}const array1dMatch=activeInfo.name.match(array1dRegexp);if(array1dMatch!==null){this.name=array1dMatch[1];this.dimensions=1}else{this.name=activeInfo.name;this.dimensions=0}this.size=activeInfo.size;this.uniformType=activeInfo.type;const glLocation=gl.getUniformLocation(program.glProgram,this.name);if(glLocation===null){throw new Error(`can not find uniform named: ${this.name}`)}this.glLocation=glLocation}}set(value){const gl=this.context.gl;switch(this.uniformType){case UniformType.Int:if(typeof value==="number"){if(value!==this.valueHashCode){gl.uniform1i(this.glLocation,value);this.valueHashCode=value}return this}if(value instanceof Array&&value.length>0&&typeof value[0]==="number"){gl.uniform1iv(this.glLocation,value);this.valueHashCode=-1;return this}break;case UniformType.Float:if(typeof value==="number"){if(value!==this.valueHashCode){gl.uniform1f(this.glLocation,value);this.valueHashCode=value}return this}if(value instanceof Array&&value.length>0&&typeof value[0]==="number"){gl.uniform1fv(this.glLocation,value);this.valueHashCode=-1;return this}break;case UniformType.FloatVec2:if(value instanceof Vector2){const hashCode=value.getHashCode();if(hashCode!==this.valueHashCode){gl.uniform2f(this.glLocation,value.x,value.y);this.valueHashCode=hashCode}return this}if(value instanceof Array&&value.length>0&&value[0]instanceof Vector2){const array=linearizeVector2FloatArray(value);gl.uniform2fv(this.glLocation,array);this.valueHashCode=-1;return this}break;case UniformType.FloatVec3:if(value instanceof Vector3){const hashCode=value.getHashCode();if(hashCode!==this.valueHashCode){gl.uniform3f(this.glLocation,value.x,value.y,value.z);this.valueHashCode=hashCode}return this}if(value instanceof Array&&value.length>0&&value[0]instanceof Vector3){const array=linearizeVector3FloatArray(value);gl.uniform3fv(this.glLocation,array);this.valueHashCode=-1;return this}break;case UniformType.FloatMat3:if(value instanceof Matrix3){const hashCode=value.getHashCode();if(hashCode!==this.valueHashCode){gl.uniformMatrix3fv(this.glLocation,false,value.elements);this.valueHashCode=hashCode}return this}if(value instanceof Array&&value.length>0&&value[0]instanceof Matrix4){const array=linearizeMatrix3FloatArray(value);gl.uniformMatrix4fv(this.glLocation,false,array);this.valueHashCode=-1;return this}break;case UniformType.FloatMat4:if(value instanceof Matrix4){const hashCode=value.getHashCode();if(hashCode!==this.valueHashCode){gl.uniformMatrix4fv(this.glLocation,false,value.elements);this.valueHashCode=hashCode}return this}if(value instanceof Array&&value.length>0&&value[0]instanceof Matrix4){const array=linearizeMatrix4FloatArray(value);gl.uniformMatrix4fv(this.glLocation,false,array);this.valueHashCode=-1;return this}break;case UniformType.Sampler2D:if(value instanceof TexImage2D){gl.activeTexture(GL.TEXTURE0+this.textureUnit);gl.bindTexture(GL.TEXTURE_2D,value.glTexture);gl.uniform1i(this.glLocation,this.textureUnit);return this}break;case UniformType.SamplerCube:if(value instanceof TexImage2D){gl.activeTexture(GL.TEXTURE0+this.textureUnit);gl.bindTexture(GL.TEXTURE_CUBE_MAP,value.glTexture);gl.uniform1i(this.glLocation,this.textureUnit);return this}break}throw new Error(`unsupported uniform type - value mismatch: ${UniformType[this.uniformType]}(${this.uniformType}) on '${this.name}'`)}}var __classPrivateFieldGet$1=undefined&&undefined.__classPrivateFieldGet||function(receiver,privateMap){if(!privateMap.has(receiver)){throw new TypeError("attempted to get private field on non-instance")}return privateMap.get(receiver)};var __classPrivateFieldSet$1=undefined&&undefined.__classPrivateFieldSet||function(receiver,privateMap,value){if(!privateMap.has(receiver)){throw new TypeError("attempted to set private field on non-instance")}privateMap.set(receiver,value);return value};var _validated$1,_uniformsInitialized,_uniforms,_attributesInitialized,_attributes;class Program{constructor(context,vertexShaderCode,fragmentShaderCode,glslVersion){this.context=context;this.disposed=false;_validated$1.set(this,false);_uniformsInitialized.set(this,false);_uniforms.set(this,{});_attributesInitialized.set(this,false);_attributes.set(this,{});this.vertexShader=new Shader(this.context,vertexShaderCode,ShaderType.Vertex,glslVersion);this.fragmentShader=new Shader(this.context,fragmentShaderCode,ShaderType.Fragment,glslVersion);const gl=this.context.gl;{const glProgram=gl.createProgram();if(glProgram===null){throw new Error("createProgram failed")}this.glProgram=glProgram}gl.attachShader(this.glProgram,this.vertexShader.glShader);gl.attachShader(this.glProgram,this.fragmentShader.glShader);gl.linkProgram(this.glProgram);this.id=this.context.registerResource(this)}validate(){if(__classPrivateFieldGet$1(this,_validated$1)||this.disposed){return true}const gl=this.context.gl;const psc=this.context.glxo.KHR_parallel_shader_compile;if(psc!==null){if(!gl.getProgramParameter(this.glProgram,psc.COMPLETION_STATUS_KHR)){return false}}if(!gl.getProgramParameter(this.glProgram,gl.LINK_STATUS)){this.vertexShader.validate();this.fragmentShader.validate();const infoLog=gl.getProgramInfoLog(this.glProgram);console.error(infoLog);this.vertexShader.dispose();this.fragmentShader.dispose();this.disposed=true;throw new Error(`program filed to link: ${infoLog}`)}__classPrivateFieldSet$1(this,_validated$1,true);return true}get uniforms(){if(!__classPrivateFieldGet$1(this,_uniformsInitialized)){let textureUnitCount=0;const gl=this.context.gl;const numActiveUniforms=gl.getProgramParameter(this.glProgram,gl.ACTIVE_UNIFORMS);for(let i=0;i<numActiveUniforms;++i){const uniform=new ProgramUniform(this,i);if(numTextureUnits(uniform.uniformType)>0){uniform.textureUnit=textureUnitCount;textureUnitCount++}__classPrivateFieldGet$1(this,_uniforms)[uniform.name]=uniform}__classPrivateFieldSet$1(this,_uniformsInitialized,true)}return __classPrivateFieldGet$1(this,_uniforms)}get attributes(){if(!__classPrivateFieldGet$1(this,_attributesInitialized)){const gl=this.context.gl;const numActiveAttributes=gl.getProgramParameter(this.glProgram,gl.ACTIVE_ATTRIBUTES);for(let i=0;i<numActiveAttributes;++i){const attribute=new ProgramAttribute(this,i);__classPrivateFieldGet$1(this,_attributes)[attribute.name]=attribute}__classPrivateFieldSet$1(this,_attributesInitialized,true)}return __classPrivateFieldGet$1(this,_attributes)}setUniformValues(uniformValueMap){this.context.program=this;for(const uniformName in uniformValueMap){const uniform=this.uniforms[uniformName];if(uniform!==undefined){uniform.set(uniformValueMap[uniformName])}}return this}setAttributeBuffers(buffers){const gl=this.context.gl;const glxVAO=this.context.glx.OES_vertex_array_object;if(buffers instanceof BufferGeometry){const bufferGeometry=buffers;for(const name in this.attributes){const attribute=this.attributes[name];const bufferAccessor=bufferGeometry.bufferAccessors[name];if(attribute!==undefined&&bufferAccessor!==undefined){attribute.setBuffer(bufferAccessor)}}if(bufferGeometry.indices!==undefined){gl.bindBuffer(bufferGeometry.indices.buffer.target,bufferGeometry.indices.buffer.glBuffer)}}else if(buffers instanceof VertexArrayObject){const vao=buffers;glxVAO.bindVertexArrayOES(vao.glVertexArrayObject)}else{throw new Error("not implemented")}return this}dispose(){if(!this.disposed){this.vertexShader.dispose();this.fragmentShader.dispose();this.context.gl.deleteProgram(this.glProgram);this.context.disposeResource(this);this.disposed=true}}}_validated$1=new WeakMap,_uniformsInitialized=new WeakMap,_uniforms=new WeakMap,_attributesInitialized=new WeakMap,_attributes=new WeakMap;function makeProgramFromShaderMaterial(context,shaderMaterial){return new Program(context,shaderMaterial.vertexShaderCode,shaderMaterial.fragmentShaderCode,shaderMaterial.glslVersion)}var _lib_shaders_includes_cubemaps_cubeFaces_glsl=`\n#ifndef _lib_shaders_includes_cubemaps_cubeFaces_glsl\n#define _lib_shaders_includes_cubemaps_cubeFaces_glsl\n\n\n// reference: https://github.com/tmarrinan/cube2equirect\nvoid directionToCubeFaceUV( vec3 dir, out int face, out vec2 uv ) {\n\n  vec3 temp;\n\n  // X dominant\n  if (abs(dir.x) >= abs(dir.y) && abs(dir.x) >= abs(dir.z)) {\n\t\tif (dir.x < 0.0) {\n      temp = vec3( dir.z, dir.y, -dir.x );\n      face = 1; // left\n\t\t}\n\t\telse {\n      temp = vec3( -dir.z, dir.y, dir.x );\n      face = 0; // right\n\t\t}\n\t}\n\n  // Y dominant\n\telse if (abs(dir.y) >= abs(dir.z)) {\n\t\tif (dir.y < 0.0) {\n      temp = vec3( dir.x, dir.z, -dir.y );\n      face = 3; // top\n\t\t}\n\t\telse {\n      temp = vec3( dir.x, -dir.z, dir.y );\n      face = 2; // bottom\n\t\t}\n\t}\n\n  // Z domnant\n\telse {\n\t\tif (dir.z < 0.0) {\n      temp = vec3( dir.x, -dir.y, dir.z );\n      face = 5; // back\n\t\t}\n\t\telse {\n      temp = vec3( dir.x, dir.y, dir.z );\n      face = 4; // front\n\t\t}\n\t}\n\n  // world to face clip space\n  vec2 clipXY = temp.xy / temp.z;\n\n  // clip space to texture space\n  uv = clipXY * 0.5 + 0.5;\n}\n\n// Ben believes this is good based on the visual results.\nvec3 cubeFaceUVToDirection(int face, vec2 uv) {\n\n  // texture space to clip space.\n  vec2 clipXY = uv * 2.0 - 1.0;\n\n  vec3 result;\n\tif(face == 0) {\n\t\tresult = vec3( 1., clipXY.y, -clipXY.x );\n  }\n  else if(face == 1) {\n\t\tresult = vec3( -1., clipXY.y, clipXY.x );\n  }\n  else if(face == 2) {\n\t\tresult =vec3( clipXY.x, 1., -clipXY.y );\n  }\n\telse if(face == 3) {\n\t\tresult =vec3( clipXY.x, -1., clipXY.y );\n  }\n\telse if(face == 4) {\n\t\tresult = vec3( clipXY.x, clipXY.y, 1. );\n  }\n\telse  {\n\t\tresult = vec3( -clipXY.x, clipXY.y, -1. );\n  }\n\n  return normalize( result );\n}\n\n\n\n#endif // end of include guard\n`;var _lib_shaders_includes_math_math_glsl=`\n#ifndef _lib_shaders_includes_math_math_glsl\n#define _lib_shaders_includes_math_math_glsl\n\n\nconst float PI = 3.141592653589793;\nconst float PI2 = 6.283185307179586;\nconst float PI_HALF = 1.5707963267948966;\nconst float RECIPROCAL_PI = 0.3183098861837907;\nconst float RECIPROCAL_PI2 = 0.15915494309189535;\nconst float EPSILON = 1e-6;\n\nfloat saturate( const in float a ) { return clamp( a, 0., 1. ); }\nvec3 saturate( const in vec3 a ) { return clamp( a, 0., 1. ); }\nvec3 whiteComplement( const in vec3 a ) { return 1. - saturate(a); }\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.333333333333 ) ); }\nfloat degToRad( const in float deg ) { return deg * PI / 180.; }\nfloat radToDeg( const in float rad ) { return rad * 180. / PI; }\n\nconst float NAN = sqrt( 0. );\nbool isnan( const in float x ) {\n  // this appears to be against the specification. another solution was offered here:\n  // https://www.shadertoy.com/view/lsjBDy\n  return (x) == NAN;\n}\nbool isinf( const in float x ) {\n  return (x) == (x)+1.;\n}\n\n\n\n#endif // end of include guard\n`;var _lib_shaders_includes_math_spherical_glsl=`\n#ifndef _lib_shaders_includes_math_spherical_glsl\n#define _lib_shaders_includes_math_spherical_glsl\n\n\n// -z is spherical axis\nvec3 nzSphericalToCartesian( vec2 s ) {\n  vec2 cs = cos( s );\n  vec2 ss = sin( s );\n\treturn vec3( cs.x * ss.y, cs.y, ss.x * ss.y );\n}\n\n// -z is spherical axis\nvec2 cartesianToNZSpherical( vec3 dir ) {\n\treturn vec2( atan( dir.z, dir.x ), acos( dir.y ) );\n}\n\n\n\n\n#endif // end of include guard\n`;var _lib_shaders_includes_cubemaps_latLong_glsl=`\n#ifndef _lib_shaders_includes_cubemaps_latLong_glsl\n#define _lib_shaders_includes_cubemaps_latLong_glsl\n\n\n${_lib_shaders_includes_math_math_glsl}\n${_lib_shaders_includes_math_spherical_glsl}\n\n/**\n * local direction -> equirectangular uvs\n */\nvec2 directionToLatLongUV( in vec3 dir ) {\n  vec2 s = cartesianToNZSpherical( dir );\n\treturn vec2(\n\t\tfract( s.x * RECIPROCAL_PI2 + 0.75 ), // this makes maps -z dir to the center of the UV space.\n\t\ts.y / PI) ;\n}\n\n/**\n * equirectangular uvs -> local direction\n */\nvec3 latLongUvToDirection( in vec2 latLongUv ) {\n  vec2 s = vec2(\n    ( latLongUv.x - 0.75 ) * PI2,\n    latLongUv.y * PI );\n  return nzSphericalToCartesian( s );\n}\n\n\n\n#endif // end of include guard\n`;var TextureWrap;(function(TextureWrap){TextureWrap[TextureWrap["MirroredRepeat"]=GL.MIRRORED_REPEAT]="MirroredRepeat";TextureWrap[TextureWrap["ClampToEdge"]=GL.CLAMP_TO_EDGE]="ClampToEdge";TextureWrap[TextureWrap["Repeat"]=GL.REPEAT]="Repeat"})(TextureWrap||(TextureWrap={}));class TexParameters{constructor(){this.generateMipmaps=true;this.wrapS=TextureWrap.Repeat;this.wrapT=TextureWrap.Repeat;this.magFilter=TextureFilter.Linear;this.minFilter=TextureFilter.LinearMipmapLinear;this.anisotropyLevels=2}}class TexImage2D{constructor(context,images,internalFormat=PixelFormat.RGBA,dataType=DataType.UnsignedByte,pixelFormat=PixelFormat.RGBA,target=TextureTarget.Texture2D,texParameters=new TexParameters){this.context=context;this.images=images;this.internalFormat=internalFormat;this.dataType=dataType;this.pixelFormat=pixelFormat;this.target=target;this.texParameters=texParameters;this.disposed=false;this.size=new Vector2;const gl=this.context.gl;{const glTexture=gl.createTexture();if(glTexture===null){throw new Error("createTexture failed")}this.glTexture=glTexture}this.loadImages(images);gl.texParameteri(this.target,GL.TEXTURE_WRAP_S,texParameters.wrapS);gl.texParameteri(this.target,GL.TEXTURE_WRAP_T,texParameters.wrapS);gl.texParameteri(this.target,GL.TEXTURE_MAG_FILTER,texParameters.magFilter);gl.texParameteri(this.target,GL.TEXTURE_MIN_FILTER,texParameters.minFilter);if(texParameters.anisotropyLevels>1){const tfa=this.context.glxo.EXT_texture_filter_anisotropic;if(tfa!==null){const maxAllowableAnisotropy=gl.getParameter(tfa.MAX_TEXTURE_MAX_ANISOTROPY_EXT);gl.texParameterf(this.target,tfa.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texParameters.anisotropyLevels,maxAllowableAnisotropy))}}if(texParameters.generateMipmaps){if(isPow2(this.size.width)&&isPow2(this.size.height)){gl.generateMipmap(this.target)}}gl.bindTexture(this.target,null);this.id=this.context.registerResource(this)}generateMipmaps(){const gl=this.context.gl;gl.bindTexture(this.target,this.glTexture);gl.generateMipmap(this.target);gl.bindTexture(this.target,null);this.texParameters.generateMipmaps=true}get mipCount(){if(!this.texParameters.generateMipmaps){return 1}return Math.floor(Math.log2(Math.max(this.size.width,this.size.height)))}dispose(){if(!this.disposed){this.context.gl.deleteTexture(this.glTexture);this.context.disposeResource(this);this.disposed=true}}loadImages(images){const gl=this.context.gl;gl.bindTexture(this.target,this.glTexture);if(images.length===1){this.loadImage(images[0])}else if(this.target===TextureTarget.TextureCubeMap){const numLevels=Math.floor(this.images.length/6);for(let level=0;level<numLevels;level++){for(let face=0;face<6;face++){const imageIndex=level*6+face;const image=images[imageIndex];this.loadImage(image,TextureTarget.CubeMapPositiveX+face,level)}}}else{throw new Error("Unsupported number of images")}}loadImage(image,target=undefined,level=0){const gl=this.context.gl;if(image instanceof Vector2){gl.texImage2D(target!==null&&target!==void 0?target:this.target,level,this.internalFormat,image.width,image.height,0,this.pixelFormat,this.dataType,null);if(level===0){this.size.copy(image)}}else if(image instanceof ArrayBufferImage){gl.texImage2D(target!==null&&target!==void 0?target:this.target,level,this.internalFormat,image.width,image.height,0,this.pixelFormat,this.dataType,new Uint8Array(image.data));if(level===0){this.size.set(image.width,image.height)}}else{gl.texImage2D(target!==null&&target!==void 0?target:this.target,level,this.internalFormat,this.pixelFormat,this.dataType,image);this.size.set(image.width,image.height)}}}var __classPrivateFieldGet$2=undefined&&undefined.__classPrivateFieldGet||function(receiver,privateMap){if(!privateMap.has(receiver)){throw new TypeError("attempted to get private field on non-instance")}return privateMap.get(receiver)};var _size;class Framebuffer extends VirtualFramebuffer{constructor(context){super(context);_size.set(this,new Vector2);this._attachments={};const gl=this.context.gl;{const glFramebuffer=gl.createFramebuffer();if(glFramebuffer===null){throw new Error("createFramebuffer failed")}this.glFramebuffer=glFramebuffer}this.id=this.context.registerResource(this)}attach(attachmentPoint,texImage2D,target=texImage2D.target,level=0){const gl=this.context.gl;gl.bindFramebuffer(GL.FRAMEBUFFER,this.glFramebuffer);gl.framebufferTexture2D(GL.FRAMEBUFFER,attachmentPoint,target,texImage2D.glTexture,level);this._attachments[attachmentPoint]=texImage2D;this.size.copy(texImage2D.size);gl.bindFramebuffer(GL.FRAMEBUFFER,null)}getAttachment(attachmentPoint){return this._attachments[attachmentPoint]}get size(){return __classPrivateFieldGet$2(this,_size)}dispose(){if(!this.disposed){const gl=this.context.gl;gl.deleteFramebuffer(this.glFramebuffer);this.context.disposeResource(this);this.disposed=true}}}_size=new WeakMap;function readPixelsFromFramebuffer(framebuffer,pixelBuffer=undefined){const context=framebuffer.context;context.framebuffer=framebuffer;const gl=context.gl;const status=gl.checkFramebufferStatus(GL.FRAMEBUFFER);if(status!==GL.FRAMEBUFFER_COMPLETE){throw new Error(`can not read non-complete Framebuffer: ${status}`)}const texImage2D=framebuffer.getAttachment(Attachment.Color0);if(texImage2D===undefined){throw new Error("no attachment on Color0")}const pixelByteLength=sizeOfDataType(texImage2D.dataType)*numPixelFormatComponents(texImage2D.pixelFormat)*texImage2D.size.width*texImage2D.size.height;if(pixelBuffer===undefined){pixelBuffer=new Uint8Array(pixelByteLength)}if(pixelBuffer.byteLength<pixelByteLength){throw new Error(`pixelBuffer too small: ${pixelBuffer.byteLength} < ${pixelByteLength}`)}gl.readPixels(0,0,texImage2D.size.width,texImage2D.size.height,texImage2D.pixelFormat,texImage2D.dataType,pixelBuffer);return pixelBuffer}function makeColorAttachment(context,size,dataType=undefined){const texParams=new TexParameters;texParams.generateMipmaps=false;texParams.magFilter=TextureFilter.Linear;texParams.minFilter=TextureFilter.Linear;return new TexImage2D(context,[size],PixelFormat.RGBA,dataType!==null&&dataType!==void 0?dataType:DataType.UnsignedByte,PixelFormat.RGBA,TextureTarget.Texture2D,texParams)}function makeDepthAttachment(context,size){const texParams=new TexParameters;texParams.generateMipmaps=false;texParams.magFilter=TextureFilter.Nearest;texParams.minFilter=TextureFilter.Nearest;const dataType=DataType.UnsignedShort;return new TexImage2D(context,[size],PixelFormat.DepthComponent,dataType,PixelFormat.DepthComponent,TextureTarget.Texture2D,texParams)}var Blending;(function(Blending){Blending[Blending["Over"]=0]="Over";Blending[Blending["Add"]=1]="Add";Blending[Blending["Subtract"]=2]="Subtract";Blending[Blending["Multiply"]=3]="Multiply"})(Blending||(Blending={}));var BlendEquation;(function(BlendEquation){BlendEquation[BlendEquation["Add"]=GL.FUNC_ADD]="Add";BlendEquation[BlendEquation["Subtract"]=GL.FUNC_SUBTRACT]="Subtract";BlendEquation[BlendEquation["ReverseSubtract"]=GL.FUNC_REVERSE_SUBTRACT]="ReverseSubtract"})(BlendEquation||(BlendEquation={}));var BlendFunc;(function(BlendFunc){BlendFunc[BlendFunc["Zero"]=GL.ZERO]="Zero";BlendFunc[BlendFunc["One"]=GL.ONE]="One";BlendFunc[BlendFunc["SourceColor"]=GL.SRC_COLOR]="SourceColor";BlendFunc[BlendFunc["OneMinusSourceColor"]=GL.ONE_MINUS_SRC_COLOR]="OneMinusSourceColor";BlendFunc[BlendFunc["DestColor"]=GL.DST_COLOR]="DestColor";BlendFunc[BlendFunc["OneMinusDestColor"]=GL.ONE_MINUS_DST_COLOR]="OneMinusDestColor";BlendFunc[BlendFunc["SourceAlpha"]=GL.SRC_ALPHA]="SourceAlpha";BlendFunc[BlendFunc["OneMinusSourceAlpha"]=GL.ONE_MINUS_SRC_ALPHA]="OneMinusSourceAlpha";BlendFunc[BlendFunc["DestAlpha"]=GL.DST_ALPHA]="DestAlpha";BlendFunc[BlendFunc["OneMinusDestAlpha"]=GL.ONE_MINUS_DST_ALPHA]="OneMinusDestAlpha";BlendFunc[BlendFunc["ConstantColor"]=GL.CONSTANT_COLOR]="ConstantColor";BlendFunc[BlendFunc["OneMinusConstantColor"]=GL.ONE_MINUS_CONSTANT_COLOR]="OneMinusConstantColor";BlendFunc[BlendFunc["ConstantAlpha"]=GL.CONSTANT_ALPHA]="ConstantAlpha";BlendFunc[BlendFunc["OneMinusConstantAlpha"]=GL.ONE_MINUS_CONSTANT_ALPHA]="OneMinusConstantAlpha";BlendFunc[BlendFunc["SourceAlphaSaturate"]=GL.SRC_ALPHA_SATURATE]="SourceAlphaSaturate"})(BlendFunc||(BlendFunc={}));class BlendState{constructor(sourceRGBFactor=BlendFunc.One,destRGBFactor=BlendFunc.Zero,sourceAlphaFactor=BlendFunc.One,destAlphaFactor=BlendFunc.Zero,equation=BlendEquation.Add){this.sourceRGBFactor=sourceRGBFactor;this.destRGBFactor=destRGBFactor;this.sourceAlphaFactor=sourceAlphaFactor;this.destAlphaFactor=destAlphaFactor;this.equation=equation}clone(){return new BlendState(this.sourceRGBFactor,this.destRGBFactor,this.sourceAlphaFactor,this.destAlphaFactor,this.equation)}copy(bs){this.sourceRGBFactor=bs.sourceRGBFactor;this.destRGBFactor=bs.destRGBFactor;this.sourceAlphaFactor=bs.sourceAlphaFactor;this.destAlphaFactor=bs.destAlphaFactor;this.equation=bs.equation}equals(bs){return this.sourceRGBFactor===bs.sourceRGBFactor&&this.destRGBFactor===bs.destRGBFactor&&this.sourceAlphaFactor===bs.sourceAlphaFactor&&this.destAlphaFactor===bs.destAlphaFactor&&this.equation===bs.equation}}var WindingOrder;(function(WindingOrder){WindingOrder[WindingOrder["Clockwise"]=GL.CW]="Clockwise";WindingOrder[WindingOrder["CounterClockwise"]=GL.CCW]="CounterClockwise"})(WindingOrder||(WindingOrder={}));var CullingSide;(function(CullingSide){CullingSide[CullingSide["Front"]=GL.FRONT]="Front";CullingSide[CullingSide["Back"]=GL.BACK]="Back";CullingSide[CullingSide["FrontBack"]=GL.FRONT_AND_BACK]="FrontBack"})(CullingSide||(CullingSide={}));class CullingState{constructor(enabled=true,sides=CullingSide.Back,windingOrder=WindingOrder.CounterClockwise){this.enabled=enabled;this.sides=sides;this.windingOrder=windingOrder}clone(){return new CullingState(this.enabled,this.sides,this.windingOrder)}copy(cs){this.enabled=cs.enabled;this.sides=cs.sides;this.windingOrder=cs.windingOrder}equals(cs){return this.enabled===cs.enabled&&this.sides===cs.sides&&this.windingOrder===cs.windingOrder}}function getRequiredExtension(gl,extensionName){const ext=gl.getExtension(extensionName);if(ext===null){throw new Error(`required extension ${extensionName} not available.`)}return ext}class Extensions{constructor(gl){this.OES_element_index_uint=getRequiredExtension(gl,"OES_element_index_uint");this.OES_standard_derivatives=getRequiredExtension(gl,"OES_standard_derivatives");this.OES_vertex_array_object=getRequiredExtension(gl,"OES_vertex_array_object");this.WEBGL_depth_texture=getRequiredExtension(gl,"WEBGL_depth_texture")}}class KHR_parallel_shader_compile{constructor(){this.MAX_SHADER_COMPILER_THREADS_KHR=37296;this.COMPLETION_STATUS_KHR=37297}}class OptionalExtensions{constructor(gl){this.EXT_shader_texture_lod=gl.getExtension("EXT_shader_texture_lod");this.EXT_texture_filter_anisotropic=gl.getExtension("EXT_texture_filter_anisotropic");this.KHR_parallel_shader_compile=gl.getExtension("KHR_parallel_shader_compile")!==null?new KHR_parallel_shader_compile:null;this.WEBGL_debug_renderer_info=gl.getExtension("WEBGL_debug_renderer_info");this.WEBGL_debug_shaders=gl.getExtension("WEBGL_debug_shaders")}}class CanvasFramebuffer extends VirtualFramebuffer{constructor(context){super(context);this.autoLayoutMode=true;this.devicePixelRatio=1;this.canvas=context.gl.canvas;this.resize()}resize(){const canvas=this.canvas;if(canvas instanceof HTMLCanvasElement){const width=Math.floor(canvas.clientWidth*this.devicePixelRatio);const height=Math.floor(canvas.clientHeight*this.devicePixelRatio);if(canvas.width!==width||canvas.height!==height){canvas.width=width;canvas.height=height}}}get size(){return new Vector2(this.context.gl.drawingBufferWidth,this.context.gl.drawingBufferHeight)}get aspectRatio(){return this.context.gl.drawingBufferWidth/this.context.gl.drawingBufferHeight}dispose(){}}class MaskState{constructor(red=true,green=true,blue=true,alpha=true,depth=true,stencil=0){this.red=red;this.green=green;this.blue=blue;this.alpha=alpha;this.depth=depth;this.stencil=stencil}clone(){return new MaskState(this.red,this.green,this.blue,this.alpha,this.depth,this.stencil)}copy(ms){this.red=ms.red;this.green=ms.green;this.blue=ms.blue;this.alpha=ms.alpha;this.depth=ms.depth;this.stencil=ms.stencil}equals(ms){return this.red===ms.red&&this.green===ms.green&&this.blue===ms.blue&&this.alpha===ms.alpha&&this.depth===ms.depth&&this.stencil===ms.stencil}}function getParameterAsString(gl,parameterId,result=""){const text=gl.getParameter(parameterId);if(typeof text==="string"){result=text}return result}var __classPrivateFieldSet$2=undefined&&undefined.__classPrivateFieldSet||function(receiver,privateMap,value){if(!privateMap.has(receiver)){throw new TypeError("attempted to set private field on non-instance")}privateMap.set(receiver,value);return value};var __classPrivateFieldGet$3=undefined&&undefined.__classPrivateFieldGet||function(receiver,privateMap){if(!privateMap.has(receiver)){throw new TypeError("attempted to get private field on non-instance")}return privateMap.get(receiver)};var _program,_framebuffer,_scissor,_viewport,_depthTestState,_blendState,_clearState,_maskState,_cullingState;class RenderingContext{constructor(canvas,attributes=undefined){this.canvas=canvas;this.resources={};this.nextResourceId=0;_program.set(this,undefined);_framebuffer.set(this,void 0);_scissor.set(this,new Box2);_viewport.set(this,new Box2);_depthTestState.set(this,new DepthTestState);_blendState.set(this,new BlendState);_clearState.set(this,new ClearState);_maskState.set(this,new MaskState);_cullingState.set(this,new CullingState);if(attributes===undefined){attributes={};attributes.alpha=true;attributes.antialias=true;attributes.depth=true;attributes.premultipliedAlpha=true;attributes.stencil=true}{const gl=canvas.getContext("webgl",attributes);if(gl===null){throw new Error("webgl not supported")}this.gl=gl}this.glx=new Extensions(this.gl);this.glxo=new OptionalExtensions(this.gl);this.canvasFramebuffer=new CanvasFramebuffer(this);__classPrivateFieldSet$2(this,_framebuffer,this.canvasFramebuffer)}registerResource(resource){const id=this.nextResourceId++;this.resources[id]=resource;return id}disposeResource(resource){delete this.resources[resource.id]}get debugVendor(){const dri=this.glxo.WEBGL_debug_renderer_info;return dri!==null?getParameterAsString(this.gl,dri.UNMASKED_VENDOR_WEBGL):""}get debugRenderer(){const dri=this.glxo.WEBGL_debug_renderer_info;return dri!==null?getParameterAsString(this.gl,dri.UNMASKED_RENDERER_WEBGL):""}set program(program){if(__classPrivateFieldGet$3(this,_program)!==program){if(program!==undefined){program.validate();this.gl.useProgram(program.glProgram)}else{this.gl.useProgram(null)}__classPrivateFieldSet$2(this,_program,program)}}get program(){return __classPrivateFieldGet$3(this,_program)}set framebuffer(framebuffer){if(__classPrivateFieldGet$3(this,_framebuffer)!==framebuffer){if(framebuffer instanceof CanvasFramebuffer){this.gl.bindFramebuffer(GL.FRAMEBUFFER,null)}else if(framebuffer instanceof Framebuffer){this.gl.bindFramebuffer(GL.FRAMEBUFFER,framebuffer.glFramebuffer)}__classPrivateFieldSet$2(this,_framebuffer,framebuffer)}}get framebuffer(){return __classPrivateFieldGet$3(this,_framebuffer)}get scissor(){return __classPrivateFieldGet$3(this,_scissor).clone()}set scissor(s){if(!__classPrivateFieldGet$3(this,_scissor).equals(s)){this.gl.scissor(s.x,s.y,s.width,s.height);__classPrivateFieldGet$3(this,_scissor).copy(s)}}get viewport(){return __classPrivateFieldGet$3(this,_viewport).clone()}set viewport(v){if(!__classPrivateFieldGet$3(this,_viewport).equals(v)){this.gl.viewport(v.x,v.y,v.width,v.height);__classPrivateFieldGet$3(this,_viewport).copy(v)}}get blendState(){return __classPrivateFieldGet$3(this,_blendState).clone()}set blendState(bs){if(!__classPrivateFieldGet$3(this,_blendState).equals(bs)){this.gl.enable(GL.BLEND);this.gl.blendEquation(bs.equation);this.gl.blendFuncSeparate(bs.sourceRGBFactor,bs.destRGBFactor,bs.sourceAlphaFactor,bs.destAlphaFactor);__classPrivateFieldGet$3(this,_blendState).copy(bs)}}get depthTestState(){return __classPrivateFieldGet$3(this,_depthTestState).clone()}set depthTestState(dts){if(!__classPrivateFieldGet$3(this,_depthTestState).equals(dts)){if(dts.enabled){this.gl.enable(GL.DEPTH_TEST)}else{this.gl.disable(GL.DEPTH_TEST)}this.gl.depthFunc(dts.func);__classPrivateFieldGet$3(this,_depthTestState).copy(dts)}}get clearState(){return __classPrivateFieldGet$3(this,_clearState).clone()}set clearState(cs){if(!__classPrivateFieldGet$3(this,_clearState).equals(cs)){this.gl.clearColor(cs.color.r,cs.color.g,cs.color.b,cs.alpha);this.gl.clearDepth(cs.depth);this.gl.clearStencil(cs.stencil);__classPrivateFieldGet$3(this,_clearState).copy(cs)}}get maskState(){return __classPrivateFieldGet$3(this,_maskState).clone()}set maskState(ms){if(!__classPrivateFieldGet$3(this,_maskState).equals(ms)){this.gl.colorMask(ms.red,ms.green,ms.blue,ms.alpha);this.gl.depthMask(ms.depth);this.gl.stencilMask(ms.stencil);__classPrivateFieldGet$3(this,_maskState).copy(ms)}}get cullingState(){return __classPrivateFieldGet$3(this,_cullingState).clone()}set cullingState(cs){if(!__classPrivateFieldGet$3(this,_cullingState).equals(cs)){if(cs.enabled){this.gl.enable(GL.CULL_FACE)}else{this.gl.disable(GL.CULL_FACE)}this.gl.frontFace(cs.windingOrder);this.gl.cullFace(cs.sides);__classPrivateFieldGet$3(this,_cullingState).copy(cs)}}renderPass(program,uniforms){throw new Error("not implemented")}render(node,camera){throw new Error("not implemented")}}_program=new WeakMap,_framebuffer=new WeakMap,_scissor=new WeakMap,_viewport=new WeakMap,_depthTestState=new WeakMap,_blendState=new WeakMap,_clearState=new WeakMap,_maskState=new WeakMap,_cullingState=new WeakMap;var vertexSource=`\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec4 v_homogeneousVertexPosition;\nvarying vec2 v_uv;\n\nvoid main() {\n\n  v_uv = uv;\n\n  // homogeneous vertex position\n  gl_Position.xy = position.xy;\n  gl_Position.z = -1.; // position at near clipping plane.  (set to 1. for far clipping plane.)\n  gl_Position.w = 1.; // nortmalized\n\n  v_homogeneousVertexPosition = gl_Position;\n\n}\n\n`;var _lib_shaders_includes_brdfs_diffuse_lambert_glsl=`\n#ifndef _lib_shaders_includes_brdfs_diffuse_lambert_glsl\n#define _lib_shaders_includes_brdfs_diffuse_lambert_glsl\n\n${_lib_shaders_includes_math_math_glsl}\n\n\n// three.js\nvec3 BRDF_Diffuse_Lambert(\n  const in vec3 albedo ) {\n\n\treturn albedo * RECIPROCAL_PI;\n\n} // validated\n\n\n/*\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nvec3 BRDF_lambertian_2(vec3 f0, vec3 f90, vec3 diffuseColor, float VdotH)\n{\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1. - F_Schlick(f0, f90, VdotH)) * (diffuseColor / M_PI);\n}\n*/\n\n\n\n#endif // end of include guard\n`;var _lib_shaders_includes_tests_fragment_glsl=`\n#ifndef _lib_shaders_includes_tests_fragment_glsl\n#define _lib_shaders_includes_tests_fragment_glsl\n\nprecision highp float;\n\nvarying vec2 v_uv;\n\nstruct TestSuite {\n  int selectorResult;\n  int selectorId;\n};\n\n// IDEA: Varying which suite test to run based on a varying from the vertex shader.\n//  This one can have multiple identified failures per run.\n\nbool eqAbs( float rhs, float lhs, float tolerance ) {\n  return abs( rhs - lhs ) < tolerance;\n}\n\nbool eqAbs( vec2 rhs, vec2 lhs, float tolerance ) {\n  return\n    eqAbs( rhs.x, lhs.x, tolerance ) &&\n    eqAbs( rhs.y, lhs.y, tolerance );\n}\n\nbool eqAbs( vec3 rhs, vec3 lhs, float tolerance ) {\n  return\n    eqAbs( rhs.x, lhs.x, tolerance ) &&\n    eqAbs( rhs.y, lhs.y, tolerance ) &&\n    eqAbs( rhs.z, lhs.z, tolerance );\n}\n\nbool eqAbs( vec4 rhs, vec4 lhs, float tolerance ) {\n  return\n    eqAbs( rhs.x, lhs.x, tolerance ) &&\n    eqAbs( rhs.y, lhs.y, tolerance ) &&\n    eqAbs( rhs.z, lhs.z, tolerance ) &&\n    eqAbs( rhs.w, lhs.w, tolerance );\n}\n\nbool eqRel( float rhs, float lhs, float tolerance ) {\n  return (abs( rhs - lhs )/max(abs(rhs),abs(lhs))) < tolerance;\n}\n\nbool eqRel( vec2 rhs, vec2 lhs, float tolerance ) {\n  return\n    eqRel( rhs.x, lhs.x, tolerance ) &&\n    eqRel( rhs.y, lhs.y, tolerance );\n}\n\nbool eqRel( vec3 rhs, vec3 lhs, float tolerance ) {\n  return\n    eqRel( rhs.x, lhs.x, tolerance ) &&\n    eqRel( rhs.y, lhs.y, tolerance ) &&\n    eqRel( rhs.z, lhs.z, tolerance );\n}\n\nbool eqRel( vec4 rhs, vec4 lhs, float tolerance ) {\n  return\n    eqRel( rhs.x, lhs.x, tolerance ) &&\n    eqRel( rhs.y, lhs.y, tolerance ) &&\n    eqRel( rhs.z, lhs.z, tolerance ) &&\n    eqRel( rhs.w, lhs.w, tolerance );\n}\n\nvoid assert( inout TestSuite suite, in int id, in bool value ) {\n  if( id != suite.selectorId ) {\n    return;\n  }\n\n  // duplicate usage of selectorId\n  if( suite.selectorResult != 2 ) {\n    suite.selectorResult = 3;\n    return;\n  }\n\n  suite.selectorResult = ( value ) ? 1 : 0;\n}\n\n// TODO: Is this actually useful?\n#define assertNotNaN(suite,id,value) asset( suite, id, !isnan(value));\n#define assertEqual(suite,id,lhs,rhs) asset( suite, id, (lhs)==(rhs));\n#define assertNotEqual(suite,id,lhs,rhs) asset( suite, id, (lhs)!=(rhs));\n#define assertGreater(suite,id,lhs,rhs) asset( suite, id, (lhs)>(rhs));\n#define assertGreaterOrEqual(suite,id,lhs,rhs) asset( suite, id, (lhs)=>(rhs));\n#define assertLess(suite,id,lhs,rhs) asset( suite, id, (lhs)<(rhs));\n#define assertLessOrEqual(suite,id,lhs,rhs) asset( suite, id, (lhs)<=(rhs));\n\nvoid initSuite( inout TestSuite suite ) {\n\n  suite.selectorId = int( floor( v_uv.x * 1024. ) );\n  suite.selectorResult = 2;\n\n}\n\nvec4 toSuiteResult( in TestSuite suite ) {\n  return vec4(\n    0.,\n    0.,\n    float( suite.selectorResult ) / 255.,\n    1. );\n}\n\nvoid tests( inout TestSuite suite );\n\nvoid main() {\n\n  TestSuite suite;\n\n  initSuite( suite );\n\n  tests( suite );\n\n  gl_FragColor = toSuiteResult( suite );\n\n}\n\n\n\n#endif // end of include guard\n`;var lambertTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_brdfs_diffuse_lambert_glsl}\n\nvoid tests( inout TestSuite suite ) {\n\n  assert( suite, 1, eqAbs( BRDF_Diffuse_Lambert( vec3( 1. ) ), vec3( RECIPROCAL_PI ), 0.0000001 ) );\n  assert( suite, 2, eqAbs( BRDF_Diffuse_Lambert( vec3( 0. ) ), vec3( 0 ), 0.0000001 ) );\n\n}\n\n`;var _lib_shaders_includes_color_encodings_rgbd_glsl=`\n#ifndef _lib_shaders_includes_color_encodings_rgbd_glsl\n#define _lib_shaders_includes_color_encodings_rgbd_glsl\n\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec3 rgbdToLinear( in vec4 value, in float maxRange ) {\n\treturn vec3( value.rgb * ( ( maxRange / 255. ) / value.a ) );\n}\n\nvec4 linearToRGBD( in vec3 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1. );\n\t// NOTE: The implementation with min causes the shader to not compile on\n\t// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests\n\t// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.\n\t// D = min( floor( D ) / 255., 1. );\n\tD = clamp( floor( D ) / 255., 0., 1. );\n\treturn vec4( value.rgb * ( D * ( 255. / maxRange ) ), D );\n}\n\n\n\n#endif // end of include guard\n`;var rgbdTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_color_encodings_rgbd_glsl}\n\nvoid testEquivalency( inout TestSuite suite, in int testId, in vec3 linear, in float maxRange ) {\n  vec4 rgbd = linearToRGBD( linear, maxRange );\n  vec3 linear2 = rgbdToLinear( rgbd, maxRange );\n  assert( suite, testId, eqRel( linear, linear2, 0.01 ) );\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  testEquivalency( suite, 1, vec3( 0.0001, 0.001, 0.01 ), 16. );\n  testEquivalency( suite, 2, vec3( 0.001 ), 16. );\n  testEquivalency( suite, 3, vec3( 0.01 ), 16. );\n  testEquivalency( suite, 4, vec3( 0.1, 1.0, 10.0 ), 16. );\n  testEquivalency( suite, 5, vec3( 1.0 ), 16. );\n  testEquivalency( suite, 6, vec3( 10.0 ), 16. );\n  testEquivalency( suite, 7, vec3( 100.0 ), 16. );\n  testEquivalency( suite, 8, vec3( 1000.0, 100.0, 10.0 ), 16. );\n\n\n  testEquivalency( suite, 11, vec3( 0.0001, 0.001, 0.01 ), 8. );\n  testEquivalency( suite, 12, vec3( 0.001 ), 128. );\n  testEquivalency( suite, 13, vec3( 0.01 ), 128. );\n  testEquivalency( suite, 14, vec3( 0.1, 1.0, 10.0 ), 32. );\n  testEquivalency( suite, 15, vec3( 1.0 ), 32. );\n  testEquivalency( suite, 16, vec3( 10.0 ), 64. );\n  testEquivalency( suite, 17, vec3( 100.0 ), 64. );\n  testEquivalency( suite, 18, vec3( 1000.0, 100.0, 10.0 ), 64. );\n\n}\n\n`;var _lib_shaders_includes_color_encodings_rgbe_glsl=`\n#ifndef _lib_shaders_includes_color_encodings_rgbe_glsl\n#define _lib_shaders_includes_color_encodings_rgbe_glsl\n\n${_lib_shaders_includes_math_math_glsl}\n\nvec3 rgbeToLinear( in vec4 value ) {\n\treturn vec3( value.rgb * exp2( value.a * 255. - 128. ) );\n}\n\nvec4 linearToRGBE( in vec3 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128., 127. );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128. ) / 255. );\n}\n\n\n\n#endif // end of include guard\n`;var rgbeTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_color_encodings_rgbe_glsl}\n\nvoid testEquivalency( inout TestSuite suite, in int testId, in vec3 linear ) {\n  vec4 rgbe = linearToRGBE( linear );\n  vec3 linear2 = rgbeToLinear( rgbe );\n  assert( suite, testId, eqRel( linear, linear2, 0.01 ) );\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  testEquivalency( suite, 1, vec3( 0.0001, 0.001, 0.01 ) );\n  testEquivalency( suite, 2, vec3( 0.001 ) );\n  testEquivalency( suite, 3, vec3( 0.01 ) );\n  testEquivalency( suite, 4, vec3( 0.1, 1.0, 10.0 ) );\n  testEquivalency( suite, 5, vec3( 1.0 ) );\n  testEquivalency( suite, 6, vec3( 10.0 ) );\n  testEquivalency( suite, 7, vec3( 100.0 ) );\n  testEquivalency( suite, 8, vec3( 1000.0, 100.0, 10.0 ) );\n\n}\n\n`;var _lib_shaders_includes_color_spaces_srgb_glsl=`\n#ifndef _lib_shaders_includes_color_spaces_srgb_glsl\n#define _lib_shaders_includes_color_spaces_srgb_glsl\n\n${_lib_shaders_includes_math_math_glsl}\n\nvec3 sRGBToLinear( in vec3 value ) {\n\treturn vec3( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ) );\n}\n\nvec3 linearTosRGB( in vec3 value ) {\n\treturn vec3( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ) );\n}\n\n\n\n#endif // end of include guard\n`;var srgbTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_color_spaces_srgb_glsl}\n\nvoid testEquivalency( inout TestSuite suite, in int testId, in vec3 srgb ) {\n  vec3 linear = sRGBToLinear( srgb );\n  vec3 srgb2 = linearTosRGB( linear );\n  assert( suite, testId, eqAbs( srgb, srgb2, 0.0001 ) );\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  testEquivalency( suite, 3, vec3( 0.) );\n  testEquivalency( suite, 4, vec3( 0.1) );\n  testEquivalency( suite, 5, vec3( 0.2) );\n  testEquivalency( suite, 6, vec3( 0.3) );\n  testEquivalency( suite, 7, vec3( 0.4) );\n  testEquivalency( suite, 8, vec3( 0.5) );\n\n}\n\n`;var cubeFacesTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_cubemaps_cubeFaces_glsl}\n\nvoid testDirectionToCubeFaceUV( inout TestSuite suite, in int testId, in vec3 dir, in int face, in vec2 uv ) {\n  int face2;\n  vec2 uv2;\n  directionToCubeFaceUV( dir, face2, uv2 );\n  assert( suite, testId, face2 == face );\n  assert( suite, testId+1, eqAbs( uv, uv2, 0.00001 ) );\n\n  vec3 dir2 = cubeFaceUVToDirection( face2, uv2 );\n  assert( suite, testId+5, eqAbs( dir, dir2, 0.0001) );\n\n}\n\nvoid testEquivalency( inout TestSuite suite, in int testId, in vec3 dir ) {\n  int face2;\n  vec2 uv2;\n  directionToCubeFaceUV( dir, face2, uv2 );\n  vec3 dir2 = cubeFaceUVToDirection( face2, uv2 );\n  assert( suite, testId, eqAbs( dir, dir2, 0.0001) );\n}\n\nvoid testEquivalencySet(  inout TestSuite suite, in int testId, in vec3 dir ) {\n  testEquivalency( suite, testId + 0, normalize( dir + vec3( 0.25, 0.25, 0.25 ) ) );\n  testEquivalency( suite, testId + 1, normalize( dir + vec3( 0.25, 0.25, -0.25 ) ) );\n  testEquivalency( suite, testId + 2, normalize( dir + vec3( 0.25, -0.25, 0.25 ) ) );\n  testEquivalency( suite, testId + 3, normalize( dir + vec3( 0.25, -0.25, -0.25 ) ) );\n  testEquivalency( suite, testId + 4, normalize( dir + vec3( -0.25, 0.25, 0.25 ) ) );\n  testEquivalency( suite, testId + 5, normalize( dir + vec3( -0.25, 0.25, -0.25 ) ) );\n  testEquivalency( suite, testId + 6, normalize( dir + vec3( -0.25, -0.25, 0.25 ) ) );\n  testEquivalency( suite, testId + 7, normalize( dir + vec3( -0.25, -0.25, -0.25 ) ) );\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  testDirectionToCubeFaceUV( suite, 0, vec3( 1., 0., 0. ), 0, vec2( 0.5, 0.5 ) );\n  testDirectionToCubeFaceUV( suite, 10, vec3( -1., 0., 0. ), 1, vec2( 0.5, 0.5 ) );\n  testDirectionToCubeFaceUV( suite, 20, vec3( 0., 1., 0. ), 2, vec2( 0.5, 0.5 ) );\n  testDirectionToCubeFaceUV( suite, 30, vec3( 0., -1., 0. ), 3, vec2( 0.5, 0.5 ) );\n  testDirectionToCubeFaceUV( suite, 40, vec3( 0., 0., 1. ), 4, vec2( 0.5, 0.5 ) );\n  testDirectionToCubeFaceUV( suite, 50, vec3( 0., 0., -1. ), 5, vec2( 0.5, 0.5 ) );\n\n  testEquivalencySet( suite, 100, vec3( 1., 0., 0. ) );\n  testEquivalencySet( suite, 110, vec3( -1., 0., 0. ) );\n  testEquivalencySet( suite, 120, vec3( 0., 1., 0. ) );\n  testEquivalencySet( suite, 130, vec3( 0., -1., 0. ) );\n  testEquivalencySet( suite, 140, vec3( 0., 0., 1. ) );\n  testEquivalencySet( suite, 150, vec3( 0., 0., -1. ) );\n\n}\n\n`;var latLongTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_cubemaps_latLong_glsl}\n\nvoid testEquivalency( inout TestSuite suite, in int testId, in vec3 dir ) {\n  vec2 uv = directionToLatLongUV( dir );\n  vec3 dir2 = latLongUvToDirection( uv );\n  vec2 uv2 = directionToLatLongUV( dir2 );\n  assert( suite, testId, eqAbs( dir, dir2, 0.00001 ) );\n  assert( suite, testId+1, eqAbs( uv, uv2, 0.00001 ) );\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  assert( suite, 0, eqAbs( directionToLatLongUV( vec3( -1, 0, 0 ) ), vec2( 0.25, 0.5 ), 0.00001 ) );\n  assert( suite, 1, eqAbs( directionToLatLongUV( vec3( 0, 0, -1 ) ), vec2( 0.5, 0.5 ), 0.00001 ) );\n  assert( suite, 2, eqAbs( directionToLatLongUV( vec3( 1, 0, 0 ) ), vec2( 0.75, 0.5 ), 0.00001 ) );\n  assert( suite, 3, eqAbs( directionToLatLongUV( vec3( 0, 0, 1 ) ), vec2( 0.0, 0.5 ), 0.00001 ) );\n\n  assert( suite, 10, eqAbs( latLongUvToDirection( vec2( 0.5, 0.5 ) ), vec3( 0.0, 0.0, -1.0 ), 0.00001 ) );\n  assert( suite, 11, eqAbs( latLongUvToDirection( vec2( 0.0, 0.5 ) ), vec3( 0.0, 0.0, 1.0 ), 0.00001 ) );\n  assert( suite, 12, eqAbs( latLongUvToDirection( vec2( 1.0, 0.5 ) ), vec3( 0.0, 0.0, 1.0 ), 0.00001 ) );\n  assert( suite, 13, eqAbs( latLongUvToDirection( vec2( 0.5, 0.0 ) ), vec3( 0.0, 1.0, 0.0 ), 0.00001 ) );\n  assert( suite, 14, eqAbs( latLongUvToDirection( vec2( 0.5, 1.0 ) ), vec3( 0.0, -1.0, 0.0 ), 0.00001 ) );\n  assert( suite, 15, eqAbs( latLongUvToDirection( vec2( 0.25, 0.5 ) ), vec3( -1.0, 0.0, 0.0 ), 0.00001 ) );\n  assert( suite, 16, eqAbs( latLongUvToDirection( vec2( 0.75, 0.5 ) ), vec3( 1.0, 0.0, 0.0 ), 0.00001 ) );\n\n  testEquivalency( suite, 20, vec3( 0., 0., 1. ) );\n  testEquivalency( suite, 30, vec3( 0., 0., -1. ) );\n  testEquivalency( suite, 40, normalize( vec3( 1., 1., 1. ) ) );\n  testEquivalency( suite, 50, normalize( vec3( 1., -1., 1. ) ) );\n  testEquivalency( suite, 60, vec3( 1., 0., 0. ) );\n  testEquivalency( suite, 70, vec3( -1., 0., 0. ) );\n  testEquivalency( suite, 80, normalize( vec3( -1., 1., 1. ) ) );\n  testEquivalency( suite, 90, normalize( vec3( -1., -1., 1. ) ) );\n  testEquivalency( suite, 110, normalize( vec3( -1., 1., -1. ) ) );\n  testEquivalency( suite, 120, normalize( vec3( -1., -1., -1. ) ) );\n  testEquivalency( suite, 130, normalize( vec3( 1., 1., -1. ) ) );\n  testEquivalency( suite, 140, normalize( vec3( 1., -1., -1. ) ) );\n\n}\n\n`;var _lib_shaders_includes_math_mat2_glsl=`\n#ifndef _lib_shaders_includes_math_mat2_glsl\n#define _lib_shaders_includes_math_mat2_glsl\n\n\nmat2 mat2Identity() {\n  return mat2( 1., 0., 0., 1. );\n}\n\nmat2 mat2RotateDirection( const in vec2 dir ){\n  return mat2( dir.x, -dir.y, dir.y, dir.x );\n}\n\n// validated - this is the same as the TS makeMatrix3RotationFromAngle\nmat2 mat2Rotate( const in float angle ){\n  return mat2RotateDirection( vec2( cos(angle), sin(angle) ) );\n}\n\n// validated - this is the same as the TS makeMatrix3Scale\nmat2 mat2Scale( const in vec2 scale ){\n  return mat2( scale.x, 0., scale.y, 0 );\n}\n\n\n\n#endif // end of include guard\n`;var mat2Tests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_math_mat2_glsl}\n\nvoid testMatEquals( inout TestSuite suite, int id, mat2 m, mat2 target ) {\n  for( int i = 0; i < 2; i ++ ) {\n    for( int j = 0; j < 2; j ++ ) {\n      assert( suite, id + i*2 + j, eqAbs( m[i][j], target[i][j], 0.000001 ) );\n    }\n  }\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  mat2 uninitialized;\n\n  mat2 zero = mat2( 0., 0., 0., 0. );\n  testMatEquals( suite, 10, uninitialized, zero );\n\n  mat2 reference = mat2( 0., 1., 2., 3. );\n\n  mat2 refByIdentity = reference * mat2Identity();\n  testMatEquals( suite, 30, refByIdentity, reference );\n\n  mat2 vec = mat2( vec2( 0., 1. ), vec2( 2., 3. ) );\n  testMatEquals( suite, 40, vec, reference );\n\n  mat2 manual;\n  manual[0] = vec2( 0., 1. );\n  manual[1].yx = vec2( 3., 2. );\n  testMatEquals( suite, 50, manual, reference );\n\n\n\n}\n\n`;var _lib_shaders_includes_math_mat3_glsl=`\n#ifndef _lib_shaders_includes_math_mat3_glsl\n#define _lib_shaders_includes_math_mat3_glsl\n\n\nmat3 mat3Identity() {\n  return mat3( 1., 0., 0., 0., 1., 0., 0., 0., 1. );\n}\n\n// validated against Three.js\nmat3 mat3RotateXDirection( const in vec2 dir ){\n  return mat3(\n    vec3( 1., 0., 0. ),\n    vec3( 0.,  dir.x, -dir.y ),\n    vec3( 0.,  dir.y,  dir.x ) );\n}\n\n// validated against Three.js\nmat3 mat3RotateYDirection( const in vec2 dir ){\n  return mat3(\n    vec3( dir.x, 0., dir.y ),\n    vec3( 0., 1., 0. ),\n    vec3( -dir.y, 0., dir.x ) );\n}\n\n// validated against Three.js\nmat3 mat3RotateZDirection( const in vec2 dir ){\n  return mat3(\n    vec3( dir.x, -dir.y, 0. ),\n    vec3( dir.y,  dir.x, 0. ),\n    vec3( 0., 0., 1. ) );\n}\n\nmat3 mat3RotateX( const in float angle ){\n  return mat3RotateXDirection( vec2( cos(angle), sin(angle) ) );\n}\n\nmat3 mat3RotateY( const in float angle ){\n  return mat3RotateYDirection( vec2( cos(angle), sin(angle) ) );\n}\n\nmat3 mat3RotateZ( const in float angle ){\n  return mat3RotateZDirection( vec2( cos(angle), sin(angle) ) );\n}\n\n// https://thebookofshaders.com/08/\nmat3 mat3Scale( const in vec3 scale ){\n  return mat3(\n    vec3( scale.x, 0., 0. ),\n    vec3( 0., scale.y, 0. ),\n    vec3( 0., 0., scale.z ) );\n}\n\n\n\n#endif // end of include guard\n`;var mat3Tests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_math_mat2_glsl}\n${_lib_shaders_includes_math_mat3_glsl}\n${_lib_shaders_includes_math_math_glsl}\n\nvoid testMatEquals( inout TestSuite suite, int id, mat3 m, mat3 target ) {\n  for( int i = 0; i < 3; i ++ ) {\n    for( int j = 0; j < 3; j ++ ) {\n      assert( suite, id + i*3 + j, eqAbs( m[i][j], target[i][j], 0.000001 ) );\n    }\n  }\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  mat3 uninitialized;\n\n  mat3 zero = mat3( 0., 0., 0., 0., 0., 0., 0., 0., 0. );\n  testMatEquals( suite, 40, uninitialized, zero );\n\n  mat3 easyIdentity = mat3(1.0);\n  testMatEquals( suite, 60, easyIdentity, mat3Identity() );\n\n  mat3 reference = mat3( 0., 1., 2., 3., 4., 5., 6., 7., 8. );\n\n  mat3 refByIdentity = reference * mat3Identity();\n  testMatEquals( suite, 80, refByIdentity, reference );\n\n  mat3 vec = mat3( vec3( 0., 1., 2. ), vec3( 3., 4., 5. ), vec3( 6., 7., 8. ) );\n  testMatEquals( suite, 100, vec, reference );\n\n  mat3 manual;\n  manual[0] = vec3( 0., 1., 2. );\n  manual[1].zyx = vec3( 5., 4., 3. );\n  manual[2].x = 6.;\n  manual[2][1] = 7.;\n  manual[2][2] = 8.;\n  testMatEquals( suite, 120, manual, reference );\n\n  mat2 m2rot90 = mat2Rotate( degToRad( 90. ) );\n  mat3 m3fromm2 = mat3( m2rot90 );  // This is a neat feature.\n  mat3 m3rot90 = mat3RotateZ( degToRad( 90. ) );\n\n  testMatEquals( suite, 200, m3fromm2, m3rot90 );\n}\n\n`;var _lib_shaders_includes_math_mat4_glsl=`\n#ifndef _lib_shaders_includes_math_mat4_glsl\n#define _lib_shaders_includes_math_mat4_glsl\n\n\nmat4 mat4Identity() {\n  return mat4(\n    1., 0., 0., 0.,\n    0., 1., 0., 0.,\n    0., 0., 1., 0.,\n    0., 0., 0., 1. );\n}\n\nmat4 mat4RotateXDirection( const in vec2 dir ){\n  return mat4(\n    vec4( 1.,     0.,    0.,  0. ),\n    vec4( 0., dir.x, -dir.y,  0. ),\n    vec4( 0., dir.y,  dir.x,  0. ),\n    vec4( 0.,     0.,    0.,  1. ) );\n}\n\nmat4 mat4RotateYDirection( const in vec2 dir ){\n  return mat4(\n    vec4( dir.x,  0., dir.y,  0. ),\n    vec4(    0.,  1.,     0.,  0. ),\n    vec4( -dir.y,  0.,  dir.x,  0. ),\n    vec4(    0.,  0.,     0.,  1. ) );\n}\n\nmat4 mat4RotateZDirection( const in vec2 dir ){\n  return mat4(\n    vec4( dir.x, -dir.y,  0.,  0. ),\n    vec4( dir.y,  dir.x,  0.,  0. ),\n    vec4(     0.,     0., 1.,  0. ),\n    vec4(     0.,     0., 0.,  1. ) );\n}\n\nmat4 mat4RotateX( const in float angle ){\n  return mat4RotateXDirection( vec2( cos(angle), sin(angle) ) );\n}\n\nmat4 mat4RotateY( const in float angle ){\n  return mat4RotateYDirection( vec2( cos(angle), sin(angle) ) );\n}\n\nmat4 mat4RotateZ( const in float angle ){\n  return mat4RotateZDirection( vec2( cos(angle), sin(angle) ) );\n}\n\n// https://thebookofshaders.com/08/\nmat3 mat3Scale( const in vec3 scale ){\n  return mat3(\n    vec3( scale.x, 0., 0. ),\n    vec3( 0., scale.y, 0. ),\n    vec3( 0., 0., scale.z ) );\n}\n\nvec3 mat4TransformPosition( const in mat4 m, const in vec3 p ) {\n    return ( m * vec4( p, 1. ) ).xyz;\n}\n\nvec3 mat4TransformDirection( const in mat4 m, const in vec3 dir ) {\n\treturn normalize( ( m * vec4( dir, 0. ) ).xyz );\n}\n\nvec3 mat4UntransformDirection( const in mat4 m, const in vec3 dir ) {\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( dir, 0. ) * m ).xyz );\n}\n\n\n\n#endif // end of include guard\n`;var mat4Tests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_math_mat4_glsl}\n${_lib_shaders_includes_math_math_glsl}\n\nvoid testMatEquals( inout TestSuite suite, int id, mat4 m, mat4 target ) {\n  for( int i = 0; i < 4; i ++ ) {\n    for( int j = 0; j < 4; j ++ ) {\n      assert( suite, id + i*4 + j, eqAbs( m[i][j], target[i][j], 0.000001 ) );\n    }\n  }\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  mat4 uninitialized;\n\n  mat4 zero = mat4(\n    0., 0., 0., 0.,\n    0., 0., 0., 0.,\n    0., 0., 0., 0.,\n    0., 0., 0., 0. );\n  testMatEquals( suite, 40, uninitialized, zero );\n\n  mat4 reference = mat4(\n    0., 1., 2., 3.,\n    4., 5., 6., 7.,\n    8., 9., 10., 11.,\n    12., 13., 14., 15. );\n\n  mat4 refByIdentity = reference * mat4Identity();\n  testMatEquals( suite, 80, refByIdentity, reference );\n\n  mat4 vec = mat4(\n    vec4( 0., 1., 2., 3. ),\n    vec4( 4., 5., 6., 7. ),\n    vec4( 8., 9., 10., 11. ),\n    vec4( 12., 13., 14., 15. ) );\n  testMatEquals( suite, 100, vec, reference );\n\n  mat4 manual;\n  manual[0] = vec4( 0., 1., 2., 3. );\n  manual[1].zyxw = vec4( 6., 5., 4., 7. );\n  manual[2].x = 8.;\n  manual[2][1] = 9.;\n  manual[2][2] = 10.;\n  manual[2][3] = 11.;\n  manual[3] = vec4( 12., 13., 14., 15. );\n  testMatEquals( suite, 120, manual, reference );\n}\n\n`;var mathTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_math_math_glsl}\n\nvoid tests( inout TestSuite suite ) {\n\n  float zero;\n  assert( suite, 0, zero == 0.0 );\n\n  vec2 zero2;\n  assert( suite, 1, length( zero2 ) == 0.0 );\n\n  vec3 zero3;\n  assert( suite, 2, length( zero3 ) == 0.0 );\n\n  vec4 zero4;\n  assert( suite, 3, length( zero4 ) == 0.0 );\n\n  assert( suite, 10, eqAbs( cos( PI ), -1., 0.000001 ) );\n  assert( suite, 11, eqAbs( cos( PI2 ), 1., 0.000001 ) );\n\n  assert( suite, 20, eqAbs( sin( PI ), 0., 0.000001 ) );\n  assert( suite, 21, eqAbs( sin( PI2 ), 0., 0.000001 ) );\n\n  assert( suite, 31, eqAbs( 0.5 * PI, PI_HALF, 0.000001 ) );\n\n  assert( suite, 41, eqAbs( 1.0 / PI, RECIPROCAL_PI, 0.000001 ) );\n  assert( suite, 42, eqAbs( 1.0 / PI2, RECIPROCAL_PI2, 0.000001 ) );\n\n  assert( suite, 50, eqAbs( saturate( -2.), 0., 0.000001 ) );\n  assert( suite, 51, eqAbs( saturate( 2.), 1., 0.000001 ) );\n\n  assert( suite, 60, eqAbs( whiteComplement( vec3( 1.0, 0.5, 0.0 ) ), vec3( 0.0, 0.5, 1.0 ), 0.000001 ) );\n\n  assert( suite, 70, pow2( 2.0 ) == 4.0 );\n  assert( suite, 71, pow2( -2.0 ) == 4.0 );\n\n  assert( suite, 80, pow3( 2.0 ) == 8.0 );\n  assert( suite, 81, pow3( -2.0 ) == -8.0 );\n\n  assert( suite, 90, pow4( 2.0 ) == 16.0 );\n  assert( suite, 91, pow4( -2.0 ) == 16.0 );\n\n  assert( suite, 100, eqAbs( average( vec3( -2.0 ) ), -2.0, 0.000001 ) );\n  assert( suite, 101, eqAbs( average( vec3( 10., 20., 30. ) ), 20., 0.000001 ) );\n\n  float divisor = 0.;\n  assert( suite, 110, ! isinf( 0. / 1. ) );\n  assert( suite, 112, isinf( 1. / divisor ) );\n\n  assert( suite, 120, isnan( sqrt( 0. ) ) );\n  assert( suite, 122, isnan( atan( 0. ) ) );\n\n  // should be undefined according to spec: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/atan.xhtml\n  assert( suite, 126, atan( 1., 0. ) == PI_HALF );\n\n  assert( suite, 200, eqAbs( degToRad( 0. ), PI * 0., 0.000001 ) );\n  assert( suite, 201, eqAbs( degToRad( 90. ), PI * 0.5, 0.000001 ) );\n  assert( suite, 202, eqAbs( degToRad( 180. ), PI * 1., 0.000001 ) );\n  assert( suite, 203, eqAbs( degToRad( 270. ), PI * 1.5, 0.000001 ) );\n  assert( suite, 204, eqAbs( degToRad( 360. ), PI * 2., 0.000001 ) );\n\n  assert( suite, 205, eqAbs( radToDeg( degToRad( 0. ) ), 0., 0.000001 ) );\n  assert( suite, 206, eqAbs( radToDeg( degToRad( 90. ) ), 90., 0.000001 ) );\n  assert( suite, 207, eqAbs( radToDeg( degToRad( 180. ) ), 180., 0.000001 ) );\n  assert( suite, 208, eqAbs( radToDeg( degToRad( 270. ) ), 270., 0.000001 ) );\n  assert( suite, 209, eqAbs( radToDeg( degToRad( 360. ) ), 360., 0.000001 ) );\n\n}\n\n`;var structsTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_math_math_glsl}\n\nstruct SimpleStruct {\n  float a;\n  vec3 b;\n};\n\nSimpleStruct getSimpleStruct() {\n  SimpleStruct ss;\n  ss.a = 1.0;\n  ss.b = vec3( 1.0, 2.0, 3.0 );\n  return ss;\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  SimpleStruct funcResult = getSimpleStruct();\n  assert( suite, 10, funcResult.a == 1.0 );\n  assert( suite, 11, funcResult.b.x == 1.0 );\n  assert( suite, 12, funcResult.b.y == 2.0 );\n  assert( suite, 13, funcResult.b.z == 3.0 );\n\n  SimpleStruct conResult = SimpleStruct( 2.0, vec3( 3.0, 4.0, 5.0 ) );\n  assert( suite, 20, conResult.a == 2.0 );\n  assert( suite, 21, conResult.b.x == 3.0 );\n  assert( suite, 22, conResult.b.y == 4.0 );\n  assert( suite, 23, conResult.b.z == 5.0 );\n\n}\n\n`;var _lib_shaders_includes_math_unitIntervalPacking_glsl=`\n#ifndef _lib_shaders_includes_math_unitIntervalPacking_glsl\n#define _lib_shaders_includes_math_unitIntervalPacking_glsl\n\n\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 unitIntervalToVec4( const in float value ) {\n\tvec4 r = vec4( fract( value * PackFactors ), value );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat vec4ToUnitInterval( const in vec4 bytes ) {\n\treturn dot( bytes, UnpackFactors );\n}\n\nvec3 unitIntervalToVec3( const in float value ) {\n\tvec3 r = vec3( fract( value * PackFactors.yz ), value );\n\tr.yz -= r.xy * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat vec3ToUnitInterval( const in vec3 bytes ) {\n\treturn dot( bytes, UnpackFactors.yzw );\n}\n\nvec2 unitIntervalToVec2( const in float value ) {\n\tvec2 r = vec2( fract( value * PackFactors.z ), value );\n\tr.y -= r.x * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat vec2ToUnitInterval( const in vec2 bytes ) {\n\treturn dot( bytes, UnpackFactors.zw );\n}\n\n\n\n#endif // end of include guard\n`;var unitIntervalPackingTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_math_unitIntervalPacking_glsl}\n\nvoid testEquivalency( inout TestSuite suite, in int testId, in float value ) {\n  vec2 packed2 = unitIntervalToVec2( value );\n  packed2.x = float( int( packed2.x * 255. ) ) / 255.;\n  packed2.y = float( int( packed2.y * 255. ) ) / 255.;\n  float value2 = vec2ToUnitInterval( packed2 );\n  assert( suite, testId+2, eqAbs( value, value2, 1./(255.*255.) ) );\n\n vec3 packed3 = unitIntervalToVec3( value );\n  packed3.x = float( int( packed3.x * 255. ) ) / 255.;\n  packed3.y = float( int( packed3.y * 255. ) ) / 255.;\n  packed3.z = float( int( packed3.z * 255. ) ) / 255.;\n  float value3 = vec3ToUnitInterval( packed3 );\n  assert( suite, testId+3, eqAbs( value, value3, 1./(255.*255.*255.) ) );\n\n  vec4 packed4 = unitIntervalToVec4( value );\n  packed4.x = float( int( packed4.x * 255. ) ) / 255.;\n  packed4.y = float( int( packed4.y * 255. ) ) / 255.;\n  packed4.z = float( int( packed4.z * 255. ) ) / 255.;\n  packed4.w = float( int( packed4.w * 255. ) ) / 255.;\n  float value4 = vec4ToUnitInterval( packed4 );\n  assert( suite, testId+4, eqAbs( value, value4, 1./(255.*255.*255.*255.) ) );\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  testEquivalency( suite, 10, 0.0 );\n  testEquivalency( suite, 20, 0.000001 );\n  testEquivalency( suite, 30, 0.000002 );\n  testEquivalency( suite, 40, 0.000003 );\n  testEquivalency( suite, 50, 0.00000321 );\n  testEquivalency( suite, 60, 0.000006421 );\n  testEquivalency( suite, 70, 0.00001 );\n  testEquivalency( suite, 80, 0.00002 );\n  testEquivalency( suite, 90, 0.00003 );\n  testEquivalency( suite, 100, 0.0000321 );\n  testEquivalency( suite, 110, 0.00006421 );\n  testEquivalency( suite, 120, 0.0001 );\n  testEquivalency( suite, 130, 0.0002 );\n  testEquivalency( suite, 140, 0.0003 );\n  testEquivalency( suite, 150, 0.000321 );\n  testEquivalency( suite, 160, 0.0006421 );\n  testEquivalency( suite, 170, 0.001 );\n  testEquivalency( suite, 180, 0.002 );\n  testEquivalency( suite, 190, 0.003 );\n  testEquivalency( suite, 200, 0.00321 );\n  testEquivalency( suite, 210, 0.006421 );\n  testEquivalency( suite, 220, 0.01 );\n  testEquivalency( suite, 230, 0.02 );\n  testEquivalency( suite, 240, 0.03 );\n  testEquivalency( suite, 250, 0.0321 );\n  testEquivalency( suite, 260, 0.06421 );\n  testEquivalency( suite, 270, 0.1 );\n  testEquivalency( suite, 280, 0.2 );\n  testEquivalency( suite, 290, 0.3 );\n  testEquivalency( suite, 300, 0.321 );\n  testEquivalency( suite, 310, 0.6421 );\n  testEquivalency( suite, 320, 1.0 );\n\n}\n\n`;var _lib_shaders_includes_normals_normalPacking_glsl=`\n#ifndef _lib_shaders_includes_normals_normalPacking_glsl\n#define _lib_shaders_includes_normals_normalPacking_glsl\n\n\nvec3 normalToRgb( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 rgbToNormal( const in vec3 rgb ) {\n\treturn 2. * rgb.xyz - 1.;\n}\n\n\n\n#endif // end of include guard\n`;var normalPackingTests=`\n${_lib_shaders_includes_tests_fragment_glsl}\n${_lib_shaders_includes_normals_normalPacking_glsl}\n\nvoid testEquivalency( inout TestSuite suite, in int testId, in vec3 normal ) {\n  vec3 rgb = normalToRgb( normal );\n  vec3 normal2 = rgbToNormal( rgb );\n  assert( suite, testId, eqAbs( normal, normal2, 0.0001 ) );\n}\n\nvoid tests( inout TestSuite suite ) {\n\n  vec3 px = vec3( 1., 0., 0. );\n  vec3 py = vec3( 0., 1., 0. );\n  vec3 pz = vec3( 0., 0., 1. );\n\n  testEquivalency( suite, 3, px );\n  testEquivalency( suite, 4, -px );\n  testEquivalency( suite, 5, py );\n  testEquivalency( suite, 6, -py );\n  testEquivalency( suite, 7, pz );\n  testEquivalency( suite, 8, -pz );\n\n}\n\n`;const glslTestSuites=[{name:"lambert",source:lambertTests},{name:"rgbd",source:rgbdTests},{name:"rgbe",source:rgbeTests},{name:"srgb",source:srgbTests},{name:"latLong",source:latLongTests},{name:"cubeFaces",source:cubeFacesTests},{name:"structs",source:structsTests},{name:"math",source:mathTests},{name:"mat2",source:mat2Tests},{name:"mat3",source:mat3Tests},{name:"mat4",source:mat4Tests},{name:"normalPacking",source:normalPackingTests},{name:"unitIntervalPacking",source:unitIntervalPackingTests}];async function init(){const geometry=passGeometry();const context=new RenderingContext(document.getElementById("framebuffer"));const canvasFramebuffer=context.canvasFramebuffer;window.addEventListener("resize",()=>canvasFramebuffer.resize());const unitUniforms={};const bufferGeometry=makeBufferGeometryFromGeometry(context,geometry);const framebufferSize=new Vector2(1024,1);const framebuffer=new Framebuffer(context);framebuffer.attach(Attachment.Color0,makeColorAttachment(context,framebufferSize));framebuffer.attach(Attachment.Depth,makeDepthAttachment(context,framebufferSize));framebuffer.clearState=new ClearState(new Vector3(.5,.5,.5),.5);framebuffer.depthTestState=new DepthTestState(true,DepthTestFunc.Less);const output=[];let totalPasses=0;let totalFailures=0;let totalDuplicates=0;glslTestSuites.forEach(glslUnitTest=>{const passIds=[];const failureIds=[];const duplicateIds=[];let compileError=undefined;try{const passMaterial=new ShaderMaterial(vertexSource,glslUnitTest.source);const unitProgram=makeProgramFromShaderMaterial(context,passMaterial);framebuffer.clear(BufferBit.All);renderBufferGeometry(framebuffer,unitProgram,unitUniforms,bufferGeometry);const result=readPixelsFromFramebuffer(framebuffer);for(let i=0;i<result.length;i+=4){const runResult=result[i+2];const id=i/4;switch(runResult){case 0:failureIds.push(id);break;case 1:passIds.push(id);break;case 3:duplicateIds.push(id);break}}}catch(e){totalFailures++;compileError=e.message!==undefined?e.message:"unknown"}totalPasses+=passIds.length;totalFailures+=failureIds.length;totalDuplicates+=duplicateIds.length;output.push(`${glslUnitTest.name}.test.glsl: ${passIds.length+failureIds.length+duplicateIds.length} tests`);if(compileError!==undefined){output.push(`  COMPILE FAILED: ${compileError}`)}else if(failureIds.length===0&&duplicateIds.length===0){output.push("  ALL PASSED")}if(failureIds.length>0){output.push(`  ${failureIds.length} FAILED: ${failureIds.join(" ")}`)}if(duplicateIds.length>0){output.push(`  ${duplicateIds.length} DUPLICATE IDS: ${duplicateIds.join(" ")}`)}output.push("")});output.push("");output.push(`SUMMARY: ${totalPasses} PASSES, ${totalFailures} FAILS, ${totalDuplicates} DUPLICATE IDS`);const textElement=document.getElementById("text");if(textElement!==null){textElement.innerHTML=output.join("<br/>")}return null}init()})();